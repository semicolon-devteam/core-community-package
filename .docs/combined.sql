-- Combined SQL file generated on #오후
-- DO NOT EDIT MANUALLY


-- =======================================
-- SCHEMA
-- =======================================

-- File: docker/volumes/db/init/schemas/01-common.sql
CREATE SCHEMA IF NOT EXISTS private;



-- File: docker/volumes/db/init/schemas/01-users.sql
-- 설명: 사용자 테이블 정의

CREATE TYPE public.gender AS ENUM ('male', 'female');
CREATE TYPE public.user_status AS ENUM ('active','inactive','suspended','dormant','pending_withdrawal','withdrawn');
CREATE TYPE public.permission_type AS ENUM (
    'super_admin', -- 최고 관리자
    'admin', -- 일반 관리자
    'moderator', -- 중재자
    'manager', -- 매니저
    'staff', -- 스태프
    'user', -- 일반 사용자
    'anonymous' -- 익명 사용자
    );

create table if not exists public.users
(
    created_at              timestamptz        default now() not null,
    updated_at              timestamptz,
    deleted_at              timestamptz,
    id                      bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    auth_user_id            uuid                             references auth.users on delete set null,
    login_id                varchar(50)                      not null,
    email                   text                             not null,
    avatar_file_id          uuid references storage.objects,
    avatar_path             text,
    status                  public.user_status DEFAULT 'active'::public.user_status,
    permission_type         public.permission_type           NOT NULL DEFAULT 'user'::public.permission_type,
    activity_level          INTEGER            DEFAULT 1,
    info_open_settings      jsonb              DEFAULT '{
      "open_email": true,
      "open_birthdate_open": true,
      "open_gender": true,
      "open_phone_number": true
    }'::jsonb,
    birthdate               date,
    gender                  public.gender,
    phone_number            text,
    invite_code             text                             not null,
    invited_by              bigint,
    nickname                varchar(50)                      not null,
    nickname_changed_at     timestamptz,
    is_withdrawal_requested boolean            default false not null
);

comment on table public.users is '유저';
comment on column public.users.id is '유저 ID';
comment on column public.users.auth_user_id is 'References the internal Supabase Auth user.';
comment on column public.users.created_at is '생성 일시';
comment on column public.users.updated_at is '수정 일시';
comment on column public.users.deleted_at is '삭제 일시';
comment on column public.users.email is '대표 이메일';
comment on column public.users.avatar_file_id is '아바타 파일 ID(Deprecated)';
comment on column users.avatar_path is '아바타 파일 Storage objects full path';
comment on column public.users.status is '계정 상태';
comment on column public.users.permission_type is '권한 타입';
comment on column public.users.activity_level is '서비스 활동 레벨';
comment on column public.users.info_open_settings is '내 정보 공개 범위 설정';
comment on column public.users.birthdate is '생년월일';
comment on column public.users.gender is '성별';
comment on column public.users.phone_number is '전화번호';
comment on column public.users.invite_code is '초대 코드';
comment on column public.users.invited_by is '초대자';
comment on column public.users.nickname is '닉네임';
comment on column public.users.nickname_changed_at is '닉네임 변경 일시';
comment on column public.users.is_withdrawal_requested is '탈퇴 요청 여부';

-- 현재 세션의 인증된 사용자 ID를 가져오는 함수
CREATE OR REPLACE FUNCTION get_user_id_from_auth_uid() RETURNS bigint
    SECURITY DEFINER
    SET search_path = public, auth
    LANGUAGE sql
    STABLE
AS $$
    SELECT COALESCE(
               -- JWT에서 먼저 시도 (0.1ms 미만)
--                    (auth.jwt() ->> 'user_id')::bigint,
               -- 없으면 DB에서 조회 (fallback)
                   (SELECT u.id FROM public.users u WHERE u.auth_user_id = auth.uid() LIMIT 1)
           );
$$;

-- 출석체크 기록 테이블
CREATE TABLE IF NOT EXISTS public.user_attendance (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id BIGINT NOT NULL DEFAULT get_user_id_from_auth_uid() REFERENCES public.users(id),
    attendance_date DATE NOT NULL DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,

    -- 동일 사용자가 하루에 한 번만 출석체크 가능
    CONSTRAINT unique_user_attendance_date UNIQUE (user_id, attendance_date)
);

COMMENT ON TABLE public.user_attendance IS '사용자 출석체크 기록';
COMMENT ON COLUMN public.user_attendance.id IS '출석체크 ID';
COMMENT ON COLUMN public.user_attendance.user_id IS '사용자 ID';
COMMENT ON COLUMN public.user_attendance.attendance_date IS '출석 날짜';
COMMENT ON COLUMN public.user_attendance.created_at IS '출석 시간';

-- 권한 변경 로그 테이블
create table if not exists public.permission_changes
(
    id         bigint primary key generated by default as identity,
    user_id    bigint references public.users (id),
    old_type   public.permission_type,
    new_type   public.permission_type,
    changed_by bigint references public.users (id),
    changed_at timestamptz default now()
);

-- 사용자 레벨 정책 테이블
CREATE TABLE IF NOT EXISTS public.user_level_configs
(
    level                   integer PRIMARY KEY,
    level_name              text,
    required_points         integer NOT NULL,
    additional_settings     jsonb            DEFAULT '{}'::jsonb,
    daily_post_limit        integer NOT NULL DEFAULT 5,
    daily_comment_limit     integer NOT NULL DEFAULT 20,
    daily_file_upload_limit integer NOT NULL DEFAULT 10
);

CREATE TABLE IF NOT EXISTS public.user_blocks (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    blocker_user_id BIGINT NOT NULL DEFAULT get_user_id_from_auth_uid() REFERENCES public.users(id) ON DELETE CASCADE,
    blocked_user_id BIGINT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    reason TEXT,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,

    -- 한 사용자가 다른 사용자를 중복해서 차단하는 것 방지
    CONSTRAINT unique_user_block UNIQUE (blocker_user_id, blocked_user_id)
);

-- 인덱스 추가
CREATE INDEX idx_user_blocks_blocker_id ON public.user_blocks(blocker_user_id);
CREATE INDEX idx_user_blocks_blocked_id ON public.user_blocks(blocked_user_id);


--- 필수 함수로 순서에 의해 여기에 작성함 ---
-- 현재 인증된 사용자의 닉네임을 가져오는 함수
CREATE OR REPLACE FUNCTION get_nickname_from_auth_uid()
    RETURNS text
    LANGUAGE sql
    STABLE
    SECURITY DEFINER
AS $$
SELECT COALESCE(
--                auth.jwt() ->> 'nickname',
               (SELECT u.nickname FROM public.users u WHERE u.auth_user_id = auth.uid() LIMIT 1)
       );
$$;

CREATE OR REPLACE FUNCTION is_admin()
    RETURNS boolean
    LANGUAGE sql
    STABLE
    SECURITY DEFINER
AS $$
SELECT COALESCE(
--                (auth.jwt() ->> 'is_admin')::boolean,
               EXISTS (
                   SELECT 1 FROM public.users u
                   WHERE u.auth_user_id = auth.uid()
                     AND u.permission_type IN ('super_admin', 'admin')
               )
       );
$$;

-- 특정 권한 체크 함수
-- 가변 인자를 받는 권한 체크 함수
CREATE OR REPLACE FUNCTION has_permission(VARIADIC allowed_permissions public.permission_type[])
    RETURNS boolean AS $$
DECLARE
    user_permission public.permission_type;
BEGIN
    -- 현재 사용자의 권한 가져오기
    SELECT u.permission_type INTO user_permission
    FROM public.users u
    WHERE u.id = get_user_id_from_auth_uid();

    -- 허용된 권한 목록에 사용자의 권한이 포함되어 있는지 확인
    RETURN user_permission = ANY(allowed_permissions);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- JWT에 권한 정보를 포함시키는 함수
create or replace function auth.user_custom_claims(uid uuid)
    returns jsonb as
$$
declare
    result jsonb;
begin
    select jsonb_build_object(
                   'permission_type', u.permission_type,
                   'user_id', u.id
           )
    into result
    from public.users u
    where u.auth_user_id = uid;

    return result;
end;
$$ language plpgsql security definer;
--- 필수 함수 끝 ---

-- File: docker/volumes/db/init/schemas/02-site-configs.sql
CREATE TYPE site_config_key AS ENUM (
    'user.register_level',
    'user.register_point',
    'user.login_point',
    'user.nickname_change_interval_days',
    'upload.allowed_ext.image',
    'upload.allowed_ext.video',
    'upload.allowed_ext.document',
    'upload.max_size.user_avatar',
    'upload.max_size.user_image',
    'terms.version',
    'maintenance_mode',
    'site.name',
    'site.title',
    'site.contact_email',
    'user.profile_fields',
    'site.forbidden_words',
    'site.terms_of_service',
    'site.privacy_policy',
    'cleanup.days_visit_logs',
    'cleanup.days_member_leave',
    'site.enable_ip_base_view_count',
    'challenge.is_enabled'
    );

-- site_config_kv 테이블 생성
CREATE TABLE IF NOT EXISTS site_config_kv
(
    key         site_config_key PRIMARY KEY,
    value       JSONB       NOT NULL,
    description TEXT,
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by  BIGINT REFERENCES users (id)
);

-- 테이블 및 컬럼 주석 추가
COMMENT ON TABLE site_config_kv IS 'Enum-key store for site-wide settings';
COMMENT ON COLUMN site_config_kv.key IS 'Enumerated config key (PK)';
COMMENT ON COLUMN site_config_kv.value IS 'JSONB-encoded value';
COMMENT ON COLUMN site_config_kv.description IS 'Human-readable description of the setting';
COMMENT ON COLUMN site_config_kv.updated_at IS 'Last update timestamp';
COMMENT ON COLUMN site_config_kv.updated_by IS 'User ID who last updated this setting';

-- 선택적 GIN 인덱스 생성 (JSON 경로 쿼리 최적화용)
CREATE INDEX IF NOT EXISTS idx_site_config_val_gin
    ON site_config_kv USING GIN (value jsonb_path_ops);

-- File: docker/volumes/db/init/schemas/03-blocked-ips.sql
-- 설명: IP 차단 테이블 정의
-- 의존성: 없음 (auth.users 테이블 참조)

-- IP 차단을 위한 테이블 생성
create table if not exists public.blocked_ips
(
    id         uuid primary key         default gen_random_uuid(),
    ip_address inet not null,
    reason     text,
    blocked_by uuid references auth.users (id),
    blocked_at timestamp with time zone default now(),
    expires_at timestamp with time zone,
    created_at timestamp with time zone default now(),
    updated_at timestamp with time zone default now()
);

COMMENT ON TABLE blocked_ips IS 'IP 차단 테이블';
COMMENT ON COLUMN blocked_ips.id IS '차단 ID';
COMMENT ON COLUMN blocked_ips.ip_address IS '차단 IP';
COMMENT ON COLUMN blocked_ips.reason IS '차단 사유';
COMMENT ON COLUMN blocked_ips.blocked_by IS '차단자 ID';
COMMENT ON COLUMN blocked_ips.blocked_at IS '차단 일시';
COMMENT ON COLUMN blocked_ips.expires_at IS '차단 만료 일시';
COMMENT ON COLUMN blocked_ips.created_at IS '생성일시';
COMMENT ON COLUMN blocked_ips.updated_at IS '수정일시';

-- IP 차단 테이블에 유니크 제약 추가
create unique index if not exists blocked_ips_ip_address_idx on public.blocked_ips (ip_address);

-- 테이블 RLS 활성화
ALTER TABLE public.blocked_ips ENABLE ROW LEVEL SECURITY;

-- 기존 정책 삭제 (만약을 위해)
DROP POLICY IF EXISTS "Allow admin select access" ON public.blocked_ips;
DROP POLICY IF EXISTS "Disallow direct modification" ON public.blocked_ips;

-- 관리자 전체 접근 허용 정책
CREATE POLICY "Allow admin full access"
    ON public.blocked_ips
    FOR ALL             -- SELECT, INSERT, UPDATE, DELETE 모두 허용
    USING (is_admin())  -- 현재 사용자가 관리자인 경우
    WITH CHECK (is_admin()); -- INSERT/UPDATE 시에도 관리자여야 함

-- 일반 사용자 읽기 전용 접근 허용 정책
CREATE POLICY "Allow public read access"
    ON public.blocked_ips
    FOR SELECT
    USING (true);       -- 모든 사용자가 SELECT 가능


-- File: docker/volumes/db/init/schemas/04-boards.sql
-- 설명: 게시판 테이블 정의

CREATE TYPE board_visibility AS ENUM ('public', 'private', 'hidden');

-- 게시판 설정 테이블
create table if not exists public.boards
(
    created_at          timestamptz      DEFAULT now() NOT NULL,
    created_by          bigint REFERENCES users (id),
    updated_at          timestamptz,
    updated_by          bigint REFERENCES users (id),
    deleted_at          timestamptz,

    id                  bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    name                text  NOT NULL,
    description         text,
    visibility          board_visibility DEFAULT 'public', -- enum: ('public', 'private', 'hidden')
    maximum_members     integer,

    -- 접근 권한 설정
    permission_settings jsonb            DEFAULT '{
      "list_level": 1,
      "read_level": 1,
      "write_level": 2,
      "comment_level": 2,
      "upload_level": 2
    }'::jsonb,

    -- 게시판 기능 설정
    feature_settings    jsonb            DEFAULT '{
      "use_category": false,
      "use_secret": false,
      "use_comments": true,
      "use_editor": true,
      "use_file_upload": true,
      "forbidden_words": []
    }'::jsonb,

    point_settings      JSONB NOT NULL   DEFAULT '{
      "read_post": 0,
      "write_post": 0,
      "write_comment": 0,
      "download_file": 0,
      "like_post": 0,
      "dislike_post": 0,
      "like_comment": 0,
      "dislike_comment": 0
    }'::jsonb,

    -- 표시 설정
    display_settings    jsonb            DEFAULT '{
      "posts_per_page": 20,
      "new_post_hours": 24,
      "hot_post_views": 100
    }'::jsonb,

    -- 파일 업로드 설정
    upload_settings     jsonb            DEFAULT '{
      "max_file_size": 5242880,
      "allowed_types": [
        "image/*",
        "application/pdf"
      ],
      "max_files": 5
    }'::jsonb,

    is_active           boolean          DEFAULT true
);

COMMENT ON TABLE boards IS '게시판 관리 테이블';
COMMENT ON COLUMN boards.id IS '게시판 고유 ID';
COMMENT ON COLUMN boards.name IS '게시판명';
COMMENT ON COLUMN boards.description IS '게시판 설명';
COMMENT ON COLUMN boards.visibility IS '게시판 공개 수준';
COMMENT ON COLUMN boards.maximum_members IS '최대 멤버 수';
COMMENT ON COLUMN boards.permission_settings IS '권한 설정 (목록/읽기/쓰기/업로드/댓글)';
COMMENT ON COLUMN boards.feature_settings IS '기능 설정 (태그/에디터/비밀글/카테고리/댓글/파일업로드)';
COMMENT ON COLUMN boards.point_settings IS '포인트 설정 (읽기/쓰기/댓글/다운로드)';
COMMENT ON COLUMN boards.display_settings IS '화면 표시 설정 (인기글 기준/새글 시간/페이지당 글 수)';
COMMENT ON COLUMN boards.upload_settings IS '업로드 설정 (최대 파일 수/허용 타입/최대 크기)';
COMMENT ON COLUMN boards.is_active IS '게시판 활성화 여부';
COMMENT ON COLUMN boards.created_at IS '생성일시';
COMMENT ON COLUMN boards.created_by IS '생성자 ID';
COMMENT ON COLUMN boards.updated_at IS '수정일시';
COMMENT ON COLUMN boards.updated_by IS '수정자 ID';
COMMENT ON COLUMN boards.deleted_at IS '삭제일시';

-- 게시판 그룹 멤버 테이블
create table if not exists public.board_users
(
    created_at timestamptz         DEFAULT now() NOT NULL,
    updated_at timestamptz,
    deleted_at timestamptz,

    id         bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    board_id   bigint     NOT NULL REFERENCES boards (id),
    user_id    bigint     NOT NULL REFERENCES users (id),

    UNIQUE (board_id, user_id, deleted_at)
);

COMMENT ON TABLE board_users IS '게시판 멤버 테이블';
COMMENT ON COLUMN board_users.id IS '게시판 멤버 고유 ID';
COMMENT ON COLUMN board_users.board_id IS '게시판 ID';
COMMENT ON COLUMN board_users.user_id IS '사용자 ID';
COMMENT ON COLUMN board_users.created_at IS '생성일시';
COMMENT ON COLUMN board_users.updated_at IS '수정일시';
COMMENT ON COLUMN board_users.deleted_at IS '삭제일시';

-- 인덱스
CREATE INDEX idx_board_members_user_id ON board_users (user_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_board_users_access ON board_users (board_id, user_id) WHERE deleted_at IS NULL;

CREATE TABLE IF NOT EXISTS board_categories (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    board_id BIGINT NOT NULL REFERENCES boards(id),
    name TEXT NOT NULL,
    description TEXT,
    display_order INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    UNIQUE(board_id, name)
);

-- File: docker/volumes/db/init/schemas/05-posts.sql
-- 설명: 게시물 테이블 정의

CREATE TYPE public.post_status AS ENUM ('draft', 'published', 'deleted', 'blocked');

-- 게시물 테이블
create table if not exists public.posts
(
    created_at    timestamptz        DEFAULT now() NOT NULL,
    created_by    bigint REFERENCES users (id),
    updated_at    timestamptz,
    updated_by    bigint REFERENCES users (id),
    deleted_at    timestamptz,

    id            bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    board_id      bigint                           NOT NULL REFERENCES public.boards (id),
    category_id   bigint                           REFERENCES public.board_categories (id), -- 카테고리 ID
    parent_id     bigint REFERENCES public.posts (id), -- 답글을 위한 참조

    -- 작성자 정보
    writer_id     bigint REFERENCES users (id) default get_user_id_from_auth_uid(),
    writer_name   text default get_nickname_from_auth_uid(),
    writer_ip     inet,

    -- 게시물 내용
    title         text                             NOT NULL,
    content       text                             NOT NULL,
    password      text,                                -- 비회원 비밀글용
    thumbnail     text,                                -- 썸네일 이미지 경로
    attachments    jsonb,
    restrict_attachments   jsonb,

    -- 게시물 상태
    status        public.post_status DEFAULT 'published'::post_status,
    is_notice     boolean            DEFAULT false,
    is_secret     boolean            DEFAULT false,
    is_anonymous  boolean            DEFAULT false,

    -- 통계
    view_count    integer            DEFAULT 0,
    comment_count integer            DEFAULT 0,
    like_count    integer            DEFAULT 0,
    dislike_count integer            DEFAULT 0,

    download_point INTEGER DEFAULT 0,

    metadata      jsonb DEFAULT '{}'::jsonb
);

COMMENT ON TABLE posts IS '게시글 관리 테이블';
COMMENT ON COLUMN posts.id IS '게시글 고유 ID';
COMMENT ON COLUMN posts.board_id IS '게시판 ID';
COMMENT ON COLUMN posts.parent_id IS '부모 게시글 ID (답글인 경우)';
COMMENT ON COLUMN posts.writer_id IS '작성자 ID';
COMMENT ON COLUMN posts.writer_name IS '작성자명';
COMMENT ON COLUMN posts.writer_ip IS '작성자 IP';
COMMENT ON COLUMN posts.title IS '게시글 제목';
COMMENT ON COLUMN posts.content IS '게시글 내용';
COMMENT ON COLUMN posts.password IS '게시글 비밀번호';
COMMENT ON COLUMN posts.attachments IS '공개 첨부파일 목록';
COMMENT ON COLUMN posts.restrict_attachments IS '접근제한 첨부파일 목록';
COMMENT ON COLUMN posts.status IS '게시글 상태';
COMMENT ON COLUMN posts.is_notice IS '공지사항 여부';
COMMENT ON COLUMN posts.is_secret IS '비밀글 여부';
COMMENT ON COLUMN posts.is_anonymous IS '익명글 여부';
COMMENT ON COLUMN posts.view_count IS '조회수';
COMMENT ON COLUMN posts.comment_count IS '댓글수';
COMMENT ON COLUMN posts.like_count IS '좋아요수';
COMMENT ON COLUMN posts.dislike_count IS '싫어요수';
COMMENT ON COLUMN posts.download_point IS '파일 다운로드 포인트 (0이면 무료)';
COMMENT ON COLUMN posts.metadata IS '게시글 메타데이터 (JSONB 형식)';
COMMENT ON COLUMN posts.created_at IS '생성일시';
COMMENT ON COLUMN posts.created_by IS '생성자 ID';
COMMENT ON COLUMN posts.updated_at IS '수정일시';
COMMENT ON COLUMN posts.updated_by IS '수정자 ID';
COMMENT ON COLUMN posts.deleted_at IS '삭제일시';

-- 1. 공개 게시글 조회 최적화
CREATE INDEX idx_posts_public_optimized ON posts
    (board_id, is_secret, deleted_at, created_at DESC)
    WHERE is_secret = false AND deleted_at IS NULL;

-- 2. 게시판별 필터링 최적화
CREATE INDEX idx_posts_board_status ON posts
    (board_id, status, deleted_at, is_secret);

-- 3. 작성자별 게시글 조회 최적화
CREATE INDEX idx_posts_writer_status ON posts
    (writer_id, deleted_at, created_at DESC)
    WHERE deleted_at IS NULL;

-- 4. 검색 성능 향상을 위한 복합 인덱스
CREATE INDEX idx_posts_search_optimized ON posts
    (board_id, deleted_at, is_secret, status)
    WHERE deleted_at IS NULL;


-- 게시물 조회 기록 테이블 (중복 조회 방지용)
create table if not exists post_views
(
    id         bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamptz DEFAULT now() NOT NULL,
    post_id    bigint                    NOT NULL REFERENCES posts (id),
    viewer_id  bigint      REFERENCES users (id),
    viewer_ip  inet                      NOT NULL
);

-- 조회 성능 최적화를 위한 새로운 인덱스
CREATE INDEX idx_post_views_user_lookup
    ON post_views (post_id, viewer_id)
    WHERE viewer_id IS NOT NULL;

CREATE INDEX idx_post_views_ip_lookup
    ON post_views (post_id, viewer_ip)
    WHERE viewer_id IS NULL;

COMMENT ON TABLE post_views IS '게시글 조회 기록 테이블';
COMMENT ON COLUMN post_views.post_id IS '게시글 ID';
COMMENT ON COLUMN post_views.viewer_id IS '조회자 ID';
COMMENT ON COLUMN post_views.viewer_ip IS '조회자 IP';
COMMENT ON COLUMN post_views.created_at IS '조회일시';

CREATE TABLE IF NOT EXISTS public.bookmark_folders (
    id            bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id       bigint NOT NULL DEFAULT get_user_id_from_auth_uid() REFERENCES public.users(id) ON DELETE CASCADE,
    name          text NOT NULL,
    created_at    timestamptz NOT NULL DEFAULT now(),
    updated_at    timestamptz,
    display_order integer DEFAULT 0, -- 폴더 순서 정렬용 (옵션)

    -- 한 사용자가 같은 이름의 폴더를 중복 생성하는 것을 방지
    CONSTRAINT bookmark_folders_user_name_unique UNIQUE (user_id, name)
);

COMMENT ON TABLE public.bookmark_folders IS '사용자 북마크 폴더';
COMMENT ON COLUMN public.bookmark_folders.id IS '폴더 고유 ID';
COMMENT ON COLUMN public.bookmark_folders.user_id IS '폴더 소유 사용자 ID';
COMMENT ON COLUMN public.bookmark_folders.name IS '폴더 이름';
COMMENT ON COLUMN public.bookmark_folders.created_at IS '폴더 생성 일시';
COMMENT ON COLUMN public.bookmark_folders.updated_at IS '폴더 수정 일시';
COMMENT ON COLUMN public.bookmark_folders.display_order IS '폴더 표시 순서';

-- 인덱스 생성
CREATE INDEX idx_bookmark_folders_user_id ON public.bookmark_folders(user_id);

CREATE TABLE IF NOT EXISTS public.post_bookmarks (
    id            bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id       bigint NOT NULL DEFAULT get_user_id_from_auth_uid() REFERENCES public.users(id) ON DELETE CASCADE,
    post_id       bigint NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    folder_id     bigint REFERENCES public.bookmark_folders(id) ON DELETE CASCADE,
    created_at    timestamptz NOT NULL DEFAULT now(),

    -- 한 사용자가 같은 게시글을 중복 북마크하는 것을 방지 (폴더와 무관하게 게시글당 한 번만)
    CONSTRAINT post_bookmarks_user_post_unique UNIQUE (user_id, post_id)
    -- 만약 폴더별로 같은 게시글 북마크 허용하려면 위 제약 대신 아래 사용:
--     CONSTRAINT post_bookmarks_folder_post_unique UNIQUE (folder_id, post_id)
);

COMMENT ON TABLE public.post_bookmarks IS '사용자 게시글 북마크 (폴더 기능)';
COMMENT ON COLUMN public.post_bookmarks.id IS '북마크 고유 ID';
COMMENT ON COLUMN public.post_bookmarks.user_id IS '북마크한 사용자 ID';
COMMENT ON COLUMN public.post_bookmarks.post_id IS '북마크된 게시글 ID';
COMMENT ON COLUMN public.post_bookmarks.folder_id IS '북마크가 속한 폴더 ID';
COMMENT ON COLUMN public.post_bookmarks.created_at IS '북마크 생성/추가 일시';

-- 인덱스 생성 (효율적인 조회를 위해)
CREATE INDEX idx_post_bookmarks_user_id ON public.post_bookmarks(user_id);
CREATE INDEX idx_post_bookmarks_post_id ON public.post_bookmarks(post_id);
CREATE INDEX idx_post_bookmarks_folder_id ON public.post_bookmarks(folder_id);

-- 설명: 게시물 검색 & 인기도 관련 뷰 및 함수
-- 제목 검색 인덱스
DROP INDEX IF EXISTS pgroonga_posts_title_index;
CREATE INDEX pgroonga_posts_title_index ON public.posts USING pgroonga (title);

-- 내용 검색 인덱스
DROP INDEX IF EXISTS pgroonga_posts_content_index;
CREATE INDEX pgroonga_posts_content_index ON public.posts USING pgroonga (content);

-- 제목 + 내용 검색 인덱스
DROP INDEX IF EXISTS pgroonga_posts_title_content_index;
CREATE INDEX pgroonga_posts_title_content_index ON public.posts USING pgroonga (title, content);

-- 게시글 인기도 계산 뷰
CREATE MATERIALIZED VIEW public.post_popularity_scores AS
SELECT
    p.id AS post_id,
    p.board_id,
    b.name,
    p.title,
    p.created_at,
    p.comment_count,
    p.like_count,
    (p.view_count * 1) +
    (p.comment_count * 7) +
    (p.like_count * 10) +
    (p.dislike_count * -2) AS popularity_score
FROM
    posts p
        JOIN boards b ON p.board_id = b.id
WHERE
    p.status = 'published'
  AND b.visibility = 'public'
  AND p.deleted_at IS NULL
  AND b.deleted_at IS NULL
  AND b.is_active = true
  AND p.created_at > CURRENT_DATE - INTERVAL '1 month';

CREATE INDEX post_popularity_scores_created_at_score_idx ON public.post_popularity_scores (created_at DESC, popularity_score DESC);
CREATE UNIQUE INDEX post_popularity_scores_post_id_unique_idx ON public.post_popularity_scores (post_id);

-- 인기 게시글 조회 함수
CREATE OR REPLACE FUNCTION posts_get_daily_popular(
    p_date timestamp DEFAULT CURRENT_TIMESTAMP,
    p_limit integer DEFAULT 10
)
    RETURNS jsonb
    SECURITY DEFINER
AS $$
DECLARE
    result jsonb;
BEGIN
    SELECT jsonb_agg(t)
    INTO result
    FROM (
             SELECT to_jsonb(pps.*) as t
             FROM post_popularity_scores pps
             WHERE
                 pps.created_at >= (p_date - INTERVAL '24 hours')
               AND pps.created_at <= p_date
             ORDER BY pps.popularity_score DESC
             LIMIT p_limit
         ) subq;

    RETURN COALESCE(result, '[]'::jsonb);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_weekly_popular_posts(
    p_date timestamp DEFAULT CURRENT_TIMESTAMP,
    p_limit integer DEFAULT 10
)
    RETURNS jsonb
    SECURITY DEFINER
AS $$
DECLARE
    result jsonb;
BEGIN
    SELECT jsonb_agg(t)
    INTO result
    FROM (
             SELECT to_jsonb(pps.*) as t
             FROM post_popularity_scores pps
             WHERE
                 pps.created_at >= (p_date - INTERVAL '7 days')
               AND pps.created_at <= p_date
             ORDER BY pps.popularity_score DESC
             LIMIT p_limit
         ) subq;

    RETURN COALESCE(result, '[]'::jsonb);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_monthly_popular_posts(
    p_date timestamp DEFAULT CURRENT_TIMESTAMP,
    p_limit integer DEFAULT 10
)
    RETURNS jsonb
    SECURITY DEFINER
AS $$
DECLARE
    result jsonb;
BEGIN
    SELECT jsonb_agg(t)
    INTO result
    FROM (
             SELECT to_jsonb(pps.*) as t
             FROM post_popularity_scores pps
             WHERE
                 pps.created_at >= (p_date - INTERVAL '30 days')
               AND pps.created_at <= p_date
             ORDER BY pps.popularity_score DESC
             LIMIT p_limit
         ) subq;

    RETURN COALESCE(result, '[]'::jsonb);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION refresh_post_popularity_scores()
    RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY post_popularity_scores;
END;
$$ LANGUAGE plpgsql;

-- 매시간 갱신하도록 스케줄링 (pg_cron 확장 필요)
SELECT cron.schedule('0 * * * *', $$
    SELECT refresh_post_popularity_scores();
$$);


-- File: docker/volumes/db/init/schemas/06-comments.sql
-- 설명: 댓글 테이블 정의

CREATE TYPE public.comment_status AS ENUM ('published', 'deleted', 'blocked');

-- 댓글 테이블
create table if not exists public.comments
(
    created_at    timestamptz           DEFAULT now() NOT NULL,
    updated_at    timestamptz,
    deleted_at    timestamptz,

    id            bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    post_id       bigint                              NOT NULL REFERENCES public.posts (id),
    parent_id     bigint REFERENCES public.comments (id), -- 대댓글을 위한 참조

    -- 작성자 정보
    writer_id     bigint REFERENCES users (id) default get_user_id_from_auth_uid(),
    writer_name   text default get_nickname_from_auth_uid(),                                   -- 비회원 작성시
    writer_ip     inet,

    -- 댓글 내용
    content       text                                NOT NULL,

    -- 댓글 상태
    status        public.comment_status DEFAULT 'published'::public.comment_status,

    -- 통계
    like_count    integer               DEFAULT 0,
    dislike_count integer               DEFAULT 0
);

COMMENT ON TABLE comments IS '댓글 관리 테이블';
COMMENT ON COLUMN comments.id IS '댓글 고유 ID';
COMMENT ON COLUMN comments.post_id IS '게시글 ID';
COMMENT ON COLUMN comments.parent_id IS '부모 댓글 ID (대댓글인 경우)';
COMMENT ON COLUMN comments.writer_id IS '작성자 ID';
COMMENT ON COLUMN comments.writer_name IS '작성자명';
COMMENT ON COLUMN comments.writer_ip IS '작성자 IP';
COMMENT ON COLUMN comments.content IS '댓글 내용';
COMMENT ON COLUMN comments.status IS '댓글 상태';
COMMENT ON COLUMN comments.like_count IS '좋아요수';
COMMENT ON COLUMN comments.dislike_count IS '싫어요수';
COMMENT ON COLUMN comments.created_at IS '생성일시';
COMMENT ON COLUMN comments.updated_at IS '수정일시';
COMMENT ON COLUMN comments.deleted_at IS '삭제일시';

CREATE INDEX idx_comments_post_id ON comments (post_id);
CREATE INDEX idx_comments_writer_id ON comments (writer_id);



-- File: docker/volumes/db/init/schemas/07-files.sql
-- 파일 다운로드 이력 테이블 생성
CREATE TABLE IF NOT EXISTS public.file_download_histories
(
    id           BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    file_path    TEXT                      NOT NULL, -- storage 의 full path
    user_id      BIGINT                    NOT NULL REFERENCES public.users (id) ON DELETE CASCADE,
    download_url TEXT,                               -- 생성된 다운로드 URL
    expires_at   TIMESTAMPTZ               NOT NULL, -- 다운로드 링크 만료시간
    point_amount INTEGER     DEFAULT 0,              -- 차감된 포인트 금액
    created_at   TIMESTAMPTZ DEFAULT now() NOT NULL,

    -- 같은 사용자가 같은 파일을 중복으로 다운로드하는 것을 방지하기 위한 유니크 제약
    CONSTRAINT unique_user_file_download UNIQUE (file_path, user_id)
);

COMMENT ON TABLE public.file_download_histories IS '파일 다운로드 이력 및 포인트 차감 기록';
COMMENT ON COLUMN public.file_download_histories.id IS '다운로드 이력 ID';
COMMENT ON COLUMN public.file_download_histories.file_path IS '파일 전체 경로';
COMMENT ON COLUMN public.file_download_histories.user_id IS '다운로드 사용자 ID';
COMMENT ON COLUMN public.file_download_histories.download_url IS '생성된 다운로드 URL';
COMMENT ON COLUMN public.file_download_histories.expires_at IS '다운로드 링크 만료시간';
COMMENT ON COLUMN public.file_download_histories.point_amount IS '차감된 포인트 금액';
COMMENT ON COLUMN public.file_download_histories.created_at IS '다운로드 일시';

-- 인덱스 생성
CREATE INDEX idx_file_download_histories_user_id ON public.file_download_histories (user_id);
CREATE INDEX idx_file_download_histories_expires_at ON public.file_download_histories (expires_at);
CREATE INDEX idx_file_download_histories_file_path ON public.file_download_histories (file_path);

-- 게시물 다운로드 이력 테이블 생성
CREATE TABLE IF NOT EXISTS public.post_download_histories
(
    id           BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    post_id      BIGINT                    NOT NULL REFERENCES public.posts (id) ON DELETE CASCADE,
    user_id      BIGINT                    NOT NULL REFERENCES public.users (id) ON DELETE CASCADE,
    point_amount INTEGER     DEFAULT 0,              -- 차감된 포인트 금액
    expires_at   TIMESTAMPTZ               NOT NULL, -- 다운로드 링크 만료시간
    created_at   TIMESTAMPTZ DEFAULT now() NOT NULL,

    -- 같은 사용자가 같은 게시물을 중복으로 다운로드하는 것을 방지하기 위한 유니크 제약
    CONSTRAINT unique_user_post_download UNIQUE (post_id, user_id)
);

COMMENT ON TABLE public.post_download_histories IS '게시물 단위 다운로드 이력 및 포인트 차감 기록';
COMMENT ON COLUMN public.post_download_histories.id IS '다운로드 이력 ID';
COMMENT ON COLUMN public.post_download_histories.post_id IS '게시물 ID';
COMMENT ON COLUMN public.post_download_histories.user_id IS '다운로드 사용자 ID';
COMMENT ON COLUMN public.post_download_histories.point_amount IS '차감된 포인트 금액';
COMMENT ON COLUMN public.file_download_histories.expires_at IS '다운로드 링크 만료시간';
COMMENT ON COLUMN public.post_download_histories.created_at IS '다운로드 일시';

-- 인덱스 생성
CREATE INDEX idx_post_download_histories_post_id ON public.post_download_histories (post_id);
CREATE INDEX idx_post_download_histories_user_id ON public.post_download_histories (user_id);
CREATE INDEX idx_post_download_histories_created_at ON public.post_download_histories (created_at DESC);

-- File: docker/volumes/db/init/schemas/08-reactions.sql
-- 설명: 게시글/댓글 반응 테이블 정의

-- 반응 대상 타입 정의
CREATE TYPE public.reaction_target_type AS ENUM ('user', 'post', 'comment');
-- 반응 타입 정의
CREATE TYPE public.reaction_type AS ENUM ('like', 'dislike');

-- 좋아요/싫어요 테이블
create table if not exists public.reactions
(
    created_at    timestamptz DEFAULT now()   NOT NULL,
    target_type   public.reaction_target_type NOT NULL,
    target_id     bigint                      NOT NULL,
    user_id       bigint DEFAULT get_user_id_from_auth_uid() NOT NULL REFERENCES users (id),
    reaction_type public.reaction_type        NOT NULL, -- enum: ('like', 'dislike')

    primary key (target_type, target_id, user_id)
);

COMMENT ON TABLE reactions IS '게시글/댓글 반응 관리 테이블';
COMMENT ON COLUMN reactions.target_type IS '대상 타입 (게시글/댓글)';
COMMENT ON COLUMN reactions.target_id IS '대상 ID';
COMMENT ON COLUMN reactions.user_id IS '사용자 ID';
COMMENT ON COLUMN reactions.reaction_type IS '반응 타입';
COMMENT ON COLUMN reactions.created_at IS '생성일시';

-- File: docker/volumes/db/init/schemas/09-menu.sql
-- 설명: 메뉴 테이블 정의

-- 메뉴 타입 정의
CREATE TYPE menu_type AS ENUM ('link', 'board');
CREATE TYPE menu_sub_type AS ENUM ('common', 'partner');

-- 메뉴 테이블
CREATE TABLE IF NOT EXISTS public.menu (
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz,
    deleted_at timestamptz,
    
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    parent_id bigint REFERENCES menu(id),
    name varchar(255) NOT NULL,
    type menu_type NOT NULL,
    sub_type menu_sub_type,
    
    -- type에 따른 링크 정보
    board_id bigint REFERENCES boards(id),  -- type = 'board'인 경우
    link_url varchar(255),                  -- type = 'link'인 경우
    
    display_order integer DEFAULT 0,
    is_pc_enabled boolean DEFAULT true,
    is_mobile_enabled boolean DEFAULT true,
    
    -- 메뉴 접근 권한 레벨
    required_level integer DEFAULT 1
);

COMMENT ON TABLE public.menu IS '메뉴 관리 테이블';
COMMENT ON COLUMN menu.id IS '메뉴 아이디';
COMMENT ON COLUMN menu.parent_id IS '상위 메뉴 아이디';
COMMENT ON COLUMN menu.name IS '메뉴 이름';
COMMENT ON COLUMN menu.type IS '메뉴 타입( link: 링크, board: 게시판)';
COMMENT ON COLUMN menu.sub_type IS '메뉴 서브 타입(common: 일반, partner: 파트너)';
COMMENT ON COLUMN menu.board_id IS '연결된 게시판 ID';
COMMENT ON COLUMN menu.link_url IS '링크 URL';
COMMENT ON COLUMN menu.display_order IS '메뉴 정렬 순서';
COMMENT ON COLUMN menu.is_pc_enabled IS 'PC에서 사용 가능 여부';
COMMENT ON COLUMN menu.is_mobile_enabled IS '모바일에서 사용 가능 여부';
COMMENT ON COLUMN menu.required_level IS '메뉴 접근에 필요한 사용자 레벨';
COMMENT ON COLUMN menu.created_at IS '생성일시';
COMMENT ON COLUMN menu.updated_at IS '수정일시';
COMMENT ON COLUMN menu.deleted_at IS '삭제일시';

-- 메뉴 인덱스 정의
CREATE INDEX idx_menu_parent_id ON menu(parent_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_menu_board_id ON menu(board_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_menu_display_order ON menu(display_order) WHERE deleted_at IS NULL;

-- File: docker/volumes/db/init/schemas/10-reports.sql
-- 파일: schemas/02-tables/10-reports.sql
-- 설명: 신고 관련 테이블 정의

-- 신고 대상 타입 정의
CREATE TYPE public.report_target_type AS ENUM ('user', 'post', 'comment');
-- 신고 상태 타입 정의
CREATE TYPE public.report_status AS ENUM ('pending', 'processing', 'completed', 'rejected');

-- 신고 유형 테이블
CREATE TABLE IF NOT EXISTS public.report_types
(
    code            TEXT PRIMARY KEY,  -- 신고 유형 코드 (SPAM, ABUSE 등)
    name            TEXT NOT NULL,     -- 신고 유형 이름
    description     TEXT,              -- 신고 유형 설명
    is_active       BOOLEAN NOT NULL DEFAULT true,  -- 활성화 여부
    display_order   INTEGER NOT NULL DEFAULT 0,     -- 표시 순서
    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at      TIMESTAMPTZ
);

COMMENT ON TABLE public.report_types IS '신고 유형 관리 테이블';
COMMENT ON COLUMN public.report_types.code IS '신고 유형 코드 (PK)';
COMMENT ON COLUMN public.report_types.name IS '신고 유형 이름';
COMMENT ON COLUMN public.report_types.description IS '신고 유형 설명';
COMMENT ON COLUMN public.report_types.is_active IS '활성화 여부';
COMMENT ON COLUMN public.report_types.display_order IS '표시 순서';
COMMENT ON COLUMN public.report_types.created_at IS '생성일시';
COMMENT ON COLUMN public.report_types.updated_at IS '수정일시';

-- 신고 내역 테이블
CREATE TABLE IF NOT EXISTS public.reports
(
    id                  BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    report_type_code    TEXT NOT NULL REFERENCES public.report_types(code),
    reporter_id         BIGINT NOT NULL DEFAULT get_user_id_from_auth_uid() REFERENCES public.users(id),
    target_type         public.report_target_type NOT NULL,  -- 신고 대상 타입 (user, post, comment)
    target_id           BIGINT NOT NULL,                     -- 신고 대상 ID
    status              public.report_status NOT NULL DEFAULT 'pending'::public.report_status,  -- 신고 상태
    content             TEXT NOT NULL,                       -- 신고 내용
    processed_by        BIGINT REFERENCES public.users(id),  -- 처리자 ID
    processed_at        TIMESTAMPTZ,                         -- 처리 일시
    process_comment     TEXT,                                -- 처리 코멘트
    created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at          TIMESTAMPTZ,
    deleted_at          TIMESTAMPTZ,

    -- 중복 신고 방지 (같은 사용자가 같은 대상을 같은 사유로 신고하는 것 방지)
    CONSTRAINT unique_report_by_user UNIQUE (reporter_id, target_type, target_id, report_type_code, deleted_at)
);

COMMENT ON TABLE public.reports IS '신고 내역 관리 테이블';
COMMENT ON COLUMN public.reports.id IS '신고 ID';
COMMENT ON COLUMN public.reports.report_type_code IS '신고 유형 코드';
COMMENT ON COLUMN public.reports.reporter_id IS '신고자 ID';
COMMENT ON COLUMN public.reports.target_type IS '신고 대상 타입';
COMMENT ON COLUMN public.reports.target_id IS '신고 대상 ID';
COMMENT ON COLUMN public.reports.status IS '신고 처리 상태';
COMMENT ON COLUMN public.reports.content IS '신고 내용';
COMMENT ON COLUMN public.reports.processed_by IS '처리자 ID';
COMMENT ON COLUMN public.reports.processed_at IS '처리 일시';
COMMENT ON COLUMN public.reports.process_comment IS '처리 코멘트';
COMMENT ON COLUMN public.reports.created_at IS '생성일시';
COMMENT ON COLUMN public.reports.updated_at IS '수정일시';
COMMENT ON COLUMN public.reports.deleted_at IS '삭제일시';

-- 인덱스 생성
CREATE INDEX idx_reports_reporter_id ON public.reports(reporter_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_reports_target ON public.reports(target_type, target_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_reports_status ON public.reports(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_reports_created_at ON public.reports(created_at) WHERE deleted_at IS NULL;

-- File: docker/volumes/db/init/schemas/11-faqs.sql
-- 설명: FAQ 및 도움말 테이블 정의
-- 의존성: 
--   schema/02-tables/01-users.sql (users 테이블 참조)

-- 도움말 카테고리 테이블
create table if not exists help_categories
(
    created_at    timestamptz DEFAULT now() NOT NULL,
    updated_at    timestamptz,
    deleted_at    timestamptz,

    id            bigint primary key GENERATED BY DEFAULT AS IDENTITY,

    code          varchar(30) UNIQUE        NOT NULL,
    name          text                      NOT NULL,
    description   text,
    icon_name     text, -- Lucide 아이콘 등을 사용할 경우
    is_active     boolean     DEFAULT true,
    display_order integer     DEFAULT 0,

    CONSTRAINT help_categories_code_check CHECK (code ~* '^[a-z0-9-_]+$')
);

comment on table help_categories is '도움말 카테고리';
comment on column help_categories.id is '도움말 카테고리 고유 ID';
comment on column help_categories.code is '도움말 카테고리 코드';
comment on column help_categories.name is '도움말 카테고리명';
comment on column help_categories.description is '도움말 카테고리 설명';
comment on column help_categories.icon_name is '아이콘명';
comment on column help_categories.is_active is '사용 여부';
comment on column help_categories.display_order is '화면 표시 순서';

-- FAQ 테이블
create table if not exists faqs
(
    created_at   timestamptz DEFAULT now() NOT NULL,
    created_by   bigint REFERENCES users (id),
    updated_at   timestamptz,
    updated_by   bigint REFERENCES users (id),
    deleted_at   timestamptz,

    id           bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    category_id  bigint                    NOT NULL REFERENCES help_categories (id),

    question     text                      NOT NULL,
    answer       text                      NOT NULL,
    is_published boolean     DEFAULT false,
    view_count   integer     DEFAULT 0,
    order_no     integer     DEFAULT 0,

    -- FAQ 추가 설정
    show_in_main boolean     DEFAULT false,
    highlight    boolean     DEFAULT false
);

COMMENT ON TABLE faqs IS '자주 묻는 질문 관리 테이블';
COMMENT ON COLUMN faqs.id IS '자주 묻는 질문 고유 ID';
COMMENT ON COLUMN faqs.category_id IS '자주 묻는 질문 카테고리 ID';
COMMENT ON COLUMN faqs.question IS '질문 내용';
COMMENT ON COLUMN faqs.answer IS '답변 내용';
COMMENT ON COLUMN faqs.is_published IS '공개 여부';
COMMENT ON COLUMN faqs.view_count IS '조회수';
COMMENT ON COLUMN faqs.order_no IS '정렬 순서';
COMMENT ON COLUMN faqs.show_in_main IS '메인페이지 노출 여부';
COMMENT ON COLUMN faqs.highlight IS '하이라이트 여부';
COMMENT ON COLUMN faqs.created_at IS '생성일시';
COMMENT ON COLUMN faqs.created_by IS '생성자 ID';
COMMENT ON COLUMN faqs.updated_at IS '수정일시';
COMMENT ON COLUMN faqs.updated_by IS '수정자 ID';
COMMENT ON COLUMN faqs.deleted_at IS '삭제일시';

-- 도움말 카테고리 인덱스
CREATE INDEX idx_help_categories_code ON help_categories (code) WHERE deleted_at IS NULL;
-- FAQ 인덱스
CREATE INDEX idx_faqs_category ON faqs (category_id) WHERE deleted_at IS NULL;
-- pgroonga 전문 검색 인덱스
CREATE INDEX pgroonga_faqs_full_text_search ON faqs USING pgroonga (question, answer);

-- File: docker/volumes/db/init/schemas/13-chat-rooms.sql
-- 설명: 채팅방 및 메시지 테이블 정의

-- 채팅방 상태 타입 정의
CREATE TYPE public.chat_room_status AS ENUM ('active', 'archived', 'deleted');
-- 메시지 상태 타입 정의
CREATE TYPE public.message_status AS ENUM ('sent', 'delivered', 'read', 'deleted');

-- 채팅방 테이블
create table if not exists public.chat_rooms
(
    created_at      timestamptz             DEFAULT now() NOT NULL,
    updated_at      timestamptz,
    deleted_at      timestamptz,
    id              bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    status          public.chat_room_status DEFAULT 'active'::public.chat_room_status,
    last_message_at timestamptz
);

COMMENT ON TABLE public.chat_rooms IS '채팅방';
COMMENT ON COLUMN public.chat_rooms.id IS '채팅방 ID';
COMMENT ON COLUMN public.chat_rooms.created_at IS '생성 일시';
COMMENT ON COLUMN public.chat_rooms.updated_at IS '수정 일시';
COMMENT ON COLUMN public.chat_rooms.deleted_at IS '삭제 일시';
COMMENT ON COLUMN public.chat_rooms.status IS '채팅방 상태';
COMMENT ON COLUMN public.chat_rooms.last_message_at IS '마지막 메시지 시간';

-- 채팅방 참여자 테이블
create table if not exists public.chat_participants
(
    id                    bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    room_id               bigint                    NOT NULL REFERENCES public.chat_rooms (id),
    user_id               bigint                    NOT NULL REFERENCES public.users (id),
    joined_at             timestamptz DEFAULT now() NOT NULL,
    last_read_at          timestamptz,
    left_at               timestamptz,
    is_active             boolean     DEFAULT true,
    notification_settings jsonb       DEFAULT '{
      "mute": false,
      "push_enabled": true
    }'::jsonb,
    UNIQUE (room_id, user_id)
);

COMMENT ON TABLE public.chat_participants IS '채팅방 참여자';
COMMENT ON COLUMN public.chat_participants.id IS '참여자 ID';
COMMENT ON COLUMN public.chat_participants.room_id IS '채팅방 ID';
COMMENT ON COLUMN public.chat_participants.user_id IS '사용자 ID';
COMMENT ON COLUMN public.chat_participants.joined_at IS '참여 일시';
COMMENT ON COLUMN public.chat_participants.last_read_at IS '마지막 읽은 시간';
COMMENT ON COLUMN public.chat_participants.left_at IS '나간 일시';
COMMENT ON COLUMN public.chat_participants.is_active IS '활성화 상태';
COMMENT ON COLUMN public.chat_participants.notification_settings IS '알림 설정';

-- 메시지 테이블
create table if not exists public.messages
(
    created_at  timestamptz           DEFAULT now() NOT NULL,
    updated_at  timestamptz,
    deleted_at  timestamptz,
    id          bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    room_id     bigint                              NOT NULL REFERENCES public.chat_rooms (id),
    sender_id   bigint                              NOT NULL REFERENCES public.users (id),
    content     text,
    file_id     UUID references storage.objects, -- 파일 첨부시 파일 ID
    status      public.message_status DEFAULT 'sent'::public.message_status,
    reply_to_id bigint REFERENCES public.messages (id),
    metadata    jsonb
);

COMMENT ON TABLE public.messages IS '채팅 메시지';
COMMENT ON COLUMN public.messages.id IS '메시지 ID';
COMMENT ON COLUMN public.messages.room_id IS '채팅방 ID';
COMMENT ON COLUMN public.messages.sender_id IS '발신자 ID';
COMMENT ON COLUMN public.messages.content IS '메시지 내용';
COMMENT ON COLUMN public.messages.created_at IS '생성 일시';
COMMENT ON COLUMN public.messages.updated_at IS '수정 일시';
COMMENT ON COLUMN public.messages.deleted_at IS '삭제 일시';
COMMENT ON COLUMN public.messages.status IS '메시지 상태';
COMMENT ON COLUMN public.messages.reply_to_id IS '답장 대상 메시지 ID';
COMMENT ON COLUMN public.messages.metadata IS '메시지 메타데이터';

-- 메시지 인덱스
CREATE INDEX idx_messages_room_id ON public.messages (room_id);
CREATE INDEX idx_messages_sender_id ON public.messages (sender_id);

-- 채팅 참여자 인덱스
CREATE INDEX idx_chat_participants_room_id ON public.chat_participants (room_id);
CREATE INDEX idx_chat_participants_user_id ON public.chat_participants (user_id);

-- File: docker/volumes/db/init/schemas/14-points.sql
-- 설명: 포인트 관련 테이블 정의

-- 포인트 만료 기간 타입 정의
CREATE TYPE POINT_EXPIRATION_PERIOD_TYPE AS ENUM ('YEAR', 'MONTH', 'DAY', 'DATE', 'WEEK', 'NEVER');
-- 포인트 트랜잭션 타입 정의
CREATE TYPE POINT_TRANSACTION_TYPE AS ENUM ('EARN', 'USE', 'REFUND', 'EXPIRE');

-- 포인트 코드 테이블
create table if not exists public.point_codes
(
    created_at  timestamptz default now(),
    updated_at  timestamptz,
    code        text not null
        constraint point_codes_pk primary key,
    name        text,
    description text
);
comment on table public.point_codes is '포인트 코드';
comment on column public.point_codes.code is '코드';
comment on column public.point_codes.created_at is '생성일시';
comment on column public.point_codes.updated_at is '수정일시';
comment on column public.point_codes.name is '이름';
comment on column public.point_codes.description is '설명';

-- 포인트 정책 테이블
create table if not exists public.point_policies
(
    created_at             timestamptz default now(),
    updated_at             timestamptz,
    id                     bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    name                   text                         not null unique,
    point_code             text                         not null references public.point_codes,
    expiration_period_type point_expiration_period_type not null,
    expiration_period      integer,
    fixed_expiration_date  date,
    is_auto_issue          boolean     default false,
    constraint valid_expiration_period
        check (((expiration_period_type = 'NEVER'::point_expiration_period_type) AND (expiration_period IS NULL) AND
                (fixed_expiration_date IS NULL)) OR
               ((expiration_period_type = 'DATE'::point_expiration_period_type) AND (expiration_period IS NULL) AND
                (fixed_expiration_date IS NOT NULL)) OR ((expiration_period_type <> ALL
                                                          (ARRAY ['NEVER'::point_expiration_period_type, 'DATE'::point_expiration_period_type])) AND
                                                         (expiration_period > 0) AND (fixed_expiration_date IS NULL)))
);

COMMENT ON TABLE point_policies IS '포인트 정책 관리 테이블';
COMMENT ON COLUMN point_policies.id IS '포인트 정책 고유 ID';
COMMENT ON COLUMN point_policies.name IS '포인트 정책 이름';
COMMENT ON COLUMN point_policies.point_code IS '포인트 코드';
COMMENT ON COLUMN point_policies.expiration_period_type IS '포인트 만료 기간 타입';
COMMENT ON COLUMN point_policies.expiration_period IS '포인트 만료 기간';
COMMENT ON COLUMN point_policies.fixed_expiration_date IS '포인트 고정 만료일';
COMMENT ON COLUMN point_policies.is_auto_issue IS '자동 발급 여부';
COMMENT ON COLUMN point_policies.created_at IS '생성일시';
COMMENT ON COLUMN point_policies.updated_at IS '수정일시';

-- 포인트 에러 로그 테이블
create table if not exists public.point_error_logs
(
    created_at      timestamptz default now(),
    id              bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    error_type      varchar(50) not null,
    error_message   text        not null,
    user_id         bigint,
    point_code      text,
    amount          numeric,
    table_name      text,
    table_record_id text,
    additional_info jsonb
);
comment on table public.point_error_logs is '포인트 관련 에러 로그';
comment on column public.point_error_logs.error_type is '에러 유형';
comment on column public.point_error_logs.error_message is '에러 메시지';
comment on column public.point_error_logs.user_id is '사용자 ID';
comment on column public.point_error_logs.point_code is '포인트 코드';
comment on column public.point_error_logs.amount is '포인트 금액';
comment on column public.point_error_logs.table_name is '테이블 이름';
comment on column public.point_error_logs.table_record_id is '레코드 ID';
comment on column public.point_error_logs.additional_info is '추가 정보';

-- 포인트 만료 로그 테이블
create table if not exists public.point_expiration_logs
(
    created_at           timestamptz default now(),
    id                   bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    execution_date       date     not null,
    total_expired_amount numeric  not null,
    execution_time       interval not null
);

comment on table public.point_expiration_logs is '포인트 만료 로그';
comment on column public.point_expiration_logs.execution_date is '실행 날짜';
comment on column public.point_expiration_logs.total_expired_amount is '총 만료된 포인트 금액';
comment on column public.point_expiration_logs.execution_time is '실행 시간';

-- 사용자 포인트 지갑 테이블
CREATE TABLE IF NOT EXISTS public.user_point_wallets
(
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    id         BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id    BIGINT                NOT NULL REFERENCES public.users (id),
    point_code TEXT                  NOT NULL REFERENCES public.point_codes (code),
    balance    NUMERIC     DEFAULT 0 NOT NULL,
    version    BIGINT      DEFAULT 0 NOT NULL,
    CONSTRAINT unique_user_point_type UNIQUE (user_id, point_code)
);

COMMENT ON TABLE user_point_wallets IS '사용자 포인트 지갑 관리 테이블';
COMMENT ON COLUMN user_point_wallets.id IS '포인트 지갑 고유 ID';
COMMENT ON COLUMN user_point_wallets.user_id IS '사용자 ID';
COMMENT ON COLUMN user_point_wallets.point_code IS '포인트 코드';
COMMENT ON COLUMN user_point_wallets.balance IS '현재 잔액';
COMMENT ON COLUMN user_point_wallets.version IS '데이터 버전 (동시성 제어용)';
COMMENT ON COLUMN user_point_wallets.created_at IS '생성일시';
COMMENT ON COLUMN user_point_wallets.updated_at IS '수정일시';

-- 포인트 거래내역 테이블
create table if not exists public.point_transactions
(
    created_at             timestamptz default now(),
    updated_at             timestamptz,
    id                     bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    user_id                bigint                 not null references public.users,
    point_code             text                   not null references public.point_codes,
    amount                 numeric                not null,
    balance_after          numeric                not null,
    transaction_type       point_transaction_type not null,
    expiration_date        date,
    description            text,
    policy_id              bigint references public.point_policies,
    related_transaction_id bigint references public.point_transactions
);

COMMENT ON TABLE point_transactions IS '포인트 거래내역 관리 테이블';
COMMENT ON COLUMN point_transactions.id IS '거래내역 고유 ID';
COMMENT ON COLUMN point_transactions.user_id IS '사용자 ID';
COMMENT ON COLUMN point_transactions.point_code IS '포인트 코드';
COMMENT ON COLUMN point_transactions.amount IS '거래 금액';
COMMENT ON COLUMN point_transactions.balance_after IS '거래 후 잔액';
COMMENT ON COLUMN point_transactions.transaction_type IS '거래 유형';
COMMENT ON COLUMN point_transactions.expiration_date IS '포인트 만료일';
COMMENT ON COLUMN point_transactions.description IS '거래 설명';
COMMENT ON COLUMN point_transactions.policy_id IS '적용된 포인트 정책 ID';
COMMENT ON COLUMN point_transactions.related_transaction_id IS '연관 거래내역 ID';
COMMENT ON COLUMN point_transactions.created_at IS '생성일시';
COMMENT ON COLUMN point_transactions.updated_at IS '수정일시';

-- File: docker/volumes/db/init/schemas/15-notifications.sql
-- 설명: 알림 관련 테이블 정의
-- 의존성: 
--   schema/02-tables/01-users.sql (users 테이블 참조)

-- 알림 템플릿 테이블
create table if not exists public.notification_templates
(
    created_at         timestamptz default now() not null,
    updated_at         timestamptz,
    template_name      text                      not null primary key,
    title              text,
    body               text,
    is_push_send       boolean     default false not null,
    is_email_send      boolean     default false not null,
    is_sms_send        boolean     default false not null,
    mobile_landing_url text,
    web_landing_url    text,
    template_group     text,
    template_sub_group text,
    is_enabled         boolean     default true  not null
);

comment on table public.notification_templates is '알림 템플릿';
comment on column public.notification_templates.template_name is '템플릿 이름';
comment on column public.notification_templates.created_at is '생성일시';
comment on column public.notification_templates.updated_at is '수정일시';
comment on column public.notification_templates.title is '제목';
comment on column public.notification_templates.body is '본문';
comment on column public.notification_templates.is_push_send is '푸시 발송 여부';
comment on column public.notification_templates.is_email_send is '이메일 발송 여부';
comment on column public.notification_templates.is_sms_send is 'SMS 발송 여부';
comment on column public.notification_templates.mobile_landing_url is '랜딩 URL';
comment on column public.notification_templates.web_landing_url is '웹 랜딩 URL';
comment on column public.notification_templates.template_group is '템플릿 그룹';
comment on column public.notification_templates.template_sub_group is '템플릿 서브 그룹';
comment on column public.notification_templates.is_enabled is '사용 여부';

-- 알림 발송 이벤트 테이블
create table if not exists public.notification_events
(
    created_at                 timestamptz default now() not null,
    updated_at                 timestamptz,
    deleted_at                 timestamptz,
    id                         bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    update_reason              text,
    user_id                    bigint references public.users,
    notification_template_name text                      not null references public.notification_templates,
    push_result                json,
    interpolation_values       json
);

comment on table public.notification_events is '알림 발송 이벤트';

-- 사용자 알림 내역 테이블
create table if not exists public.user_notifications
(
    created_at         timestamptz default now() not null,
    updated_at         timestamptz,
    id                 bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    user_id            bigint                    not null references public.users (id),
    title              text                      not null,
    body               text,
    mobile_landing_url text,
    web_landing_url    text,
    is_read            boolean     default false not null,
    params             json
);

comment on table public.user_notifications is '사용자별 알림 내역';
comment on column public.user_notifications.params is '랜딩 url 파라미터';

-- 알림 예약 발송 테이블
create table if not exists public.notification_schedules
(
    created_at                 timestamptz default now() not null,
    updated_at                 timestamptz,
    id                         bigint primary key GENERATED BY DEFAULT AS IDENTITY,
    user_ids                   bigint[]                  not null,
    notification_template_name text                      not null,
    interpolation_values       json,
    scheduled_at               timestamptz               not null,
    is_sent                    boolean     default false not null,
    sent_at                    timestamptz,
    error_message              text,
    retry_count                integer     default 0     not null,
    next_retry_at              timestamptz
);

comment on table public.notification_schedules is '알림 예약 발송을 위한 예약 정보 관리 테이블';
comment on column public.notification_schedules.user_ids is '알림을 받을 사용자 ID 배열';
comment on column public.notification_schedules.notification_template_name is '사용할 알림 템플릿 이름';
comment on column public.notification_schedules.interpolation_values is '알림 템플릿에 사용될 동적 데이터';
comment on column public.notification_schedules.scheduled_at is '알림 예약 시간';
comment on column public.notification_schedules.sent_at is '실제 알림 발송 시간';
comment on column public.notification_schedules.error_message is '발송 실패시 에러 메시지';
comment on column public.notification_schedules.retry_count is '재시도 횟수';
comment on column public.notification_schedules.next_retry_at is '다음 재시도 예정 시간';

-- 알림 예약 인덱스
create index if not exists idx_notification_schedules_user_ids on public.notification_schedules using gin (user_ids);
create index if not exists idx_notification_schedules_scheduled_at on public.notification_schedules (scheduled_at);

-- File: docker/volumes/db/init/schemas/16-banners.sql
-- 설명: 배너 관련 테이블 정의

-- 배너 위치 정보를 위한 enum 타입
CREATE TYPE public.banner_position AS ENUM (
    'LEFT_SIDE', -- 좌측 사이드
    'RIGHT_SIDE', -- 우측 사이드
    'CENTER', -- 중앙
    'TOP', -- 상단
    'BOTTOM', -- 하단
    'POPUP', -- 팝업
    'FLOATING' -- 플로팅
    );

-- 배너 상태 정보를 위한 enum 타입
CREATE TYPE public.banner_status AS ENUM (
    'DRAFT', -- 임시저장
    'ACTIVE', -- 활성화
    'PAUSED', -- 일시중지
    'DELETED' -- 삭제됨
);

-- 디바이스 타입 정보를 위한 enum 타입
CREATE TYPE public.device_type AS ENUM ('PC', 'MOBILE', 'TABLET');

-- 배너 마스터 테이블
CREATE TABLE IF NOT EXISTS public.banners
(
    -- 메타 정보
    created_at        timestamp with time zone NOT NULL DEFAULT now(),
    created_by        bigint,
    updated_at        timestamp with time zone,
    updated_by        bigint,
    deleted_at        timestamp with time zone,

    -- 기본 정보
    id                bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title             text                     NOT NULL,                  -- 배너 제목 (관리용)
    description       text,                                               -- 배너 설명
    position          banner_position          NOT NULL,                  -- 배너 위치
    image_url         text                     NOT NULL,                  -- 배너 이미지 URL
    link_url          text,                                               -- 클릭 시 이동할 URL
    target_window     text                              DEFAULT '_blank', -- 링크 타겟 (_self, _blank)

    -- 노출 조건
    start_at        timestamp with time zone NOT NULL,                  -- 노출 시작일시
    end_at          timestamp with time zone NOT NULL,                  -- 노출 종료일시
    display_order     integer                           DEFAULT 0,        -- 노출 순서

    -- 노출 대상
    target_devices    public.device_type[],                                      -- 노출할 디바이스 (pc, mobile, tablet)

    -- 스타일 설정
    width             integer,                                            -- 너비 (px)
    height            integer,                                            -- 높이 (px)
    is_responsive     boolean                           DEFAULT false,    -- 반응형 여부

    -- 상태 정보
    status            banner_status            NOT NULL DEFAULT 'DRAFT',

    -- 통계 정보 (캐시)
    click_count       integer                           DEFAULT 0,        -- 클릭 횟수

    -- 제약조건
    CONSTRAINT banners_date_check CHECK (start_at < end_at)
);

COMMENT ON TABLE banners IS '배너 관리 테이블';
COMMENT ON COLUMN banners.id IS '배너 고유 ID';
COMMENT ON COLUMN banners.title IS '배너 제목';
COMMENT ON COLUMN banners.description IS '배너 설명';
COMMENT ON COLUMN banners.position IS '배너 위치';
COMMENT ON COLUMN banners.image_url IS '배너 이미지 URL';
COMMENT ON COLUMN banners.link_url IS '클릭 시 이동할 URL';
COMMENT ON COLUMN banners.target_window IS '링크 타겟';
COMMENT ON COLUMN banners.start_at IS '노출 시작일시';
COMMENT ON COLUMN banners.end_at IS '노출 종료일시';
COMMENT ON COLUMN banners.display_order IS '노출 순서';
COMMENT ON COLUMN banners.target_devices IS '노출할 디바이스';
COMMENT ON COLUMN banners.width IS '너비';
COMMENT ON COLUMN banners.height IS '높이';
COMMENT ON COLUMN banners.is_responsive IS '반응형 여부';
COMMENT ON COLUMN banners.status IS '배너 상태';
COMMENT ON COLUMN banners.click_count IS '클릭 횟수';
COMMENT ON COLUMN banners.created_at IS '생성일시';
COMMENT ON COLUMN banners.created_by IS '생성자 ID';
COMMENT ON COLUMN banners.updated_at IS '수정일시';
COMMENT ON COLUMN banners.updated_by IS '수정자 ID';
COMMENT ON COLUMN banners.deleted_at IS '삭제일시';

-- File: docker/volumes/db/init/schemas/17-badges.sql
-- 뱃지 상태를 위한 ENUM 타입 생성
CREATE TYPE badge_status AS ENUM (
    'DRAFT',       -- 초안 상태 (관리자만 볼 수 있음)
    'PUBLISHED',   -- 발행됨 (사용자에게 표시됨)
    'ARCHIVED'     -- 보관됨 (더 이상 새로운 획득은 불가능하지만 이미 획득한 사용자는 유지)
    );

CREATE TABLE IF NOT EXISTS public.badges
(
    id              BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at      TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    created_by      BIGINT REFERENCES users (id),
    updated_at      TIMESTAMPTZ,
    updated_by      BIGINT REFERENCES users (id),
    deleted_at      TIMESTAMPTZ,
    name            TEXT                      NOT NULL,   -- 뱃지 이름
    description     TEXT,                                 -- 뱃지 설명
    file_id         UUID REFERENCES storage.objects (id), -- 뱃지 파일 ID storage.objects 참조
    badge_type      TEXT                      NOT NULL,   -- 뱃지 유형 (예: 'achievement', 'purchase', 'special' 등)
    required_points INTEGER,                              -- 구매 시 필요한 포인트 (구매형 뱃지인 경우)
    is_purchasable  BOOLEAN     DEFAULT FALSE,            -- 구매 가능 여부
    status badge_status NOT NULL DEFAULT 'DRAFT'         -- 뱃지 상태
);

COMMENT ON TABLE public.badges IS '뱃지 마스터 테이블';
COMMENT ON COLUMN public.badges.id IS '뱃지 ID';
COMMENT ON COLUMN public.badges.created_at IS '생성일시';
COMMENT ON COLUMN public.badges.updated_at IS '수정일시';
COMMENT ON COLUMN public.badges.deleted_at IS '삭제일시';
COMMENT ON COLUMN public.badges.created_by IS '생성자 ID';
COMMENT ON COLUMN public.badges.updated_by IS '수정자 ID';
COMMENT ON COLUMN public.badges.name IS '뱃지 이름';
COMMENT ON COLUMN public.badges.description IS '뱃지 설명';
COMMENT ON COLUMN public.badges.file_id IS '뱃지 파일 ID';
COMMENT ON COLUMN public.badges.badge_type IS '뱃지 유형';
COMMENT ON COLUMN public.badges.required_points IS '필요 포인트';
COMMENT ON COLUMN public.badges.is_purchasable IS '구매 가능 여부';
COMMENT ON COLUMN public.badges.status IS '뱃지 상태 (DRAFT: 초안, PUBLISHED: 발행됨, ARCHIVED: 보관됨)';

CREATE TABLE IF NOT EXISTS public.user_badges
(
    id               BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at       TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at       TIMESTAMPTZ,
    user_id          BIGINT                    NOT NULL REFERENCES users (id),
    badge_id         BIGINT                    NOT NULL REFERENCES badges (id),
    acquired_at      TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    acquisition_type TEXT                      NOT NULL,        -- 'purchase', 'achievement', 'admin_grant' 등
    is_active        BOOLEAN     DEFAULT FALSE,
    transaction_id   BIGINT REFERENCES point_transactions (id), -- 구매 시 포인트 트랜잭션 참조
    CONSTRAINT unique_user_badge UNIQUE (user_id, badge_id)    -- 사용자별 중복 뱃지 방지
);

-- 트리거 함수: 새 뱃지 활성화 시 다른 활성 뱃지 비활성화
CREATE OR REPLACE FUNCTION manage_active_badges()
    RETURNS TRIGGER AS $$
BEGIN
    -- 새 뱃지가 활성화되면 동일 사용자의 다른 활성 뱃지 비활성화
    IF NEW.is_active = true THEN
        UPDATE public.user_badges
        SET is_active = false
        WHERE user_id = NEW.user_id
          AND id != NEW.id
          AND is_active = true;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 트리거 생성
CREATE TRIGGER trig_manage_active_badges
    BEFORE INSERT OR UPDATE ON public.user_badges
    FOR EACH ROW
EXECUTE FUNCTION manage_active_badges();

COMMENT ON TABLE public.user_badges IS '사용자 보유 뱃지 테이블';
COMMENT ON COLUMN public.user_badges.id IS '소유 뱃지 ID';
COMMENT ON COLUMN public.user_badges.created_at IS '생성일시';
COMMENT ON COLUMN public.user_badges.updated_at IS '수정일시';
COMMENT ON COLUMN public.user_badges.user_id IS '사용자 ID';
COMMENT ON COLUMN public.user_badges.badge_id IS '뱃지 ID';
COMMENT ON COLUMN public.user_badges.acquired_at IS '뱃지 획득 일시';
COMMENT ON COLUMN public.user_badges.acquisition_type IS '뱃지 획득 방법';
COMMENT ON COLUMN public.user_badges.is_active IS '활성화 여부';
COMMENT ON COLUMN public.user_badges.transaction_id IS '포인트 트랜잭션 ID';

CREATE TYPE badge_condition_type AS ENUM (
    'post_count', -- 게시물 수
    'comment_count', -- 댓글 수
    'attendance_days', -- 출석일 수
    'point_purchase', -- 포인트 구매
    'level' -- 사용자 레벨
    );

CREATE TABLE IF NOT EXISTS public.badge_conditions
(
    id              BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at      TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at      TIMESTAMPTZ,
    badge_id        BIGINT                    NOT NULL REFERENCES badges (id),
    condition_type  TEXT                      NOT NULL, -- 'post_count', 'comment_count', 'attendance_days', 'point_purchase' 등
    condition_value INTEGER                   NOT NULL, -- 조건 값 (예: 게시물 수, 댓글 수, 출석 일수 등)
    CONSTRAINT unique_badge_condition UNIQUE (badge_id, condition_type)
);

COMMENT ON TABLE public.badge_conditions IS '뱃지 지급 조건 테이블';
COMMENT ON COLUMN public.badge_conditions.id IS '조건 ID';
COMMENT ON COLUMN public.badge_conditions.created_at IS '생성일시';
COMMENT ON COLUMN public.badge_conditions.updated_at IS '수정일시';
COMMENT ON COLUMN public.badge_conditions.badge_id IS '뱃지 ID';
COMMENT ON COLUMN public.badge_conditions.condition_type IS '조건 유형';
COMMENT ON COLUMN public.badge_conditions.condition_value IS '조건 값';

-- 뱃지 지급 조건 추가
-- 뱃지 구매 로직 추가

-- File: docker/volumes/db/init/schemas/18-coins.sql
CREATE TABLE IF NOT EXISTS public.coin_types
(
    created_at          TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at          TIMESTAMPTZ,

    coin_code           TEXT PRIMARY KEY, -- 코인 코드 (PK)
    coin_name           TEXT                      NOT NULL,
    coin_symbol         TEXT                      NOT NULL,

    is_purchase_enabled BOOLEAN     DEFAULT true  NOT NULL,
    is_active           BOOLEAN     DEFAULT true  NOT NULL,

    display_order       INTEGER     DEFAULT 0,
    icon_url            TEXT,             -- 코인 아이콘 이미지 URL
    description         TEXT,             -- 코인 설명

    metadata            JSONB       DEFAULT '{}'::jsonb
);

COMMENT ON TABLE public.coin_types IS '코인 타입 관리 테이블';
COMMENT ON COLUMN public.coin_types.coin_code IS '코인 코드 (Primary Key)';
COMMENT ON COLUMN public.coin_types.coin_name IS '코인 이름';
COMMENT ON COLUMN public.coin_types.coin_symbol IS '코인 심볼';
COMMENT ON COLUMN public.coin_types.is_purchase_enabled IS '포인트 구매 가능 여부';
COMMENT ON COLUMN public.coin_types.is_active IS '코인 활성 상태';
COMMENT ON COLUMN public.coin_types.display_order IS '표시 순서';
COMMENT ON COLUMN public.coin_types.icon_url IS '코인 아이콘 이미지 URL';
COMMENT ON COLUMN public.coin_types.description IS '코인 설명';
COMMENT ON COLUMN public.coin_types.metadata IS '메타데이터 (JSONB)';
COMMENT ON COLUMN public.coin_types.created_at IS '생성일시';
COMMENT ON COLUMN public.coin_types.updated_at IS '수정일시';

INSERT INTO public.coin_types (coin_code, coin_name, coin_symbol, display_order, description)
VALUES ('bitcoin', '비트코인', 'BTC', 1, null),
       ('ethereum', '이더리움', 'ETH', 2, null),
       ('ripple', '리플', 'XRP', 3, null),
       ('other', '기타', 'OTHER', 99, '목록에 없는 기타 코인')
ON CONFLICT (coin_code) DO NOTHING;

CREATE TABLE IF NOT EXISTS public.coin_point_purchase_requests
(
    created_at             TIMESTAMPTZ DEFAULT now()       NOT NULL,
    updated_at             TIMESTAMPTZ,

    id                     BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,

    user_id                BIGINT                          NOT NULL REFERENCES public.users (id) ON DELETE CASCADE,

    coin_code              TEXT                            NOT NULL REFERENCES public.coin_types (coin_code),
    coin_name_custom       TEXT,           -- 기타 코인인 경우 직접 입력
    exchange_name          TEXT,           -- 거래소 이름 (선택적, 기타 코인 구매시 사용)
    payment_method         TEXT                            NOT NULL CHECK (
        payment_method IN ('agency', 'exchange_direct', 'personal_wallet')
    ),
    deposit_amount         INTEGER      NOT NULL,
    wallet_address         TEXT                            NOT NULL CHECK (LENGTH(wallet_address) >= 10),
    transaction_id         TEXT                            NOT NULL CHECK (LENGTH(transaction_id) >= 5),
    point_code             TEXT                            NOT NULL REFERENCES public.point_codes (code),
    status                 TEXT        DEFAULT 'requested' NOT NULL CHECK (
        status IN ('requested', 'cancelled', 'approved', 'rejected', 'refunded')
    ),

    processed_by           BIGINT REFERENCES public.users (id),
    processed_at           TIMESTAMPTZ,
    admin_notes            TEXT,           -- 관리자 메모
    rejection_reason       TEXT,           -- 거절 사유

    issued_point_amount    INTEGER CHECK (issued_point_amount IS NULL OR issued_point_amount > 0), -- 실제 지급된 포인트 (승인시)

    metadata               JSONB       DEFAULT '{}'::jsonb
);

-- 테이블 및 컬럼 코멘트
COMMENT ON TABLE public.coin_point_purchase_requests IS '코인 포인트 구매 요청 관리 테이블';
COMMENT ON COLUMN public.coin_point_purchase_requests.id IS '구매 요청 고유 ID';
COMMENT ON COLUMN public.coin_point_purchase_requests.created_at IS '요청 생성일시';
COMMENT ON COLUMN public.coin_point_purchase_requests.updated_at IS '수정일시';
COMMENT ON COLUMN public.coin_point_purchase_requests.user_id IS '요청 사용자 ID';
COMMENT ON COLUMN public.coin_point_purchase_requests.coin_code IS '코인 코드 (coin_types 테이블 참조)';
COMMENT ON COLUMN public.coin_point_purchase_requests.coin_name_custom IS '기타 코인 직접 입력명';
COMMENT ON COLUMN public.coin_point_purchase_requests.exchange_name IS '거래소 이름';
COMMENT ON COLUMN public.coin_point_purchase_requests.payment_method IS '결제 방식 (agency: 대행업체, exchange_direct: 거래소 직접송금, personal_wallet: 개인지갑 전송)';
COMMENT ON COLUMN public.coin_point_purchase_requests.deposit_amount IS '입금 금액';
COMMENT ON COLUMN public.coin_point_purchase_requests.wallet_address IS '코인 지갑 주소 (최소 10자)';
COMMENT ON COLUMN public.coin_point_purchase_requests.transaction_id IS '트랜잭션 ID (최소 5자)';
COMMENT ON COLUMN public.coin_point_purchase_requests.point_code IS '포인트 코드 (point_codes 테이블 참조)';
COMMENT ON COLUMN public.coin_point_purchase_requests.status IS '구매 요청 상태 (requested: 요청, cancelled: 요청 취소, approved: 구매 승인, rejected: 구매 거절, refunded: 환불)';
COMMENT ON COLUMN public.coin_point_purchase_requests.processed_by IS '처리한 관리자 사용자 ID';
COMMENT ON COLUMN public.coin_point_purchase_requests.processed_at IS '처리 일시';
COMMENT ON COLUMN public.coin_point_purchase_requests.admin_notes IS '관리자 메모';
COMMENT ON COLUMN public.coin_point_purchase_requests.rejection_reason IS '거절 사유';
COMMENT ON COLUMN public.coin_point_purchase_requests.issued_point_amount IS '실제 지급된 포인트 금액 (승인시)';
COMMENT ON COLUMN public.coin_point_purchase_requests.metadata IS '메타데이터 (JSONB 형식)';

CREATE INDEX IF NOT EXISTS idx_coin_point_purchase_requests_user_id ON public.coin_point_purchase_requests (user_id);
CREATE INDEX IF NOT EXISTS idx_coin_point_purchase_requests_status ON public.coin_point_purchase_requests (status, created_at DESC);

CREATE UNIQUE INDEX idx_coin_purchase_requests_unique_transaction
    ON public.coin_point_purchase_requests(coin_code, wallet_address, transaction_id)
    WHERE status NOT IN ('cancelled', 'rejected');

ALTER TABLE public.coin_point_purchase_requests ENABLE ROW LEVEL SECURITY;

CREATE POLICY "유저 조회 권한" ON public.coin_point_purchase_requests FOR SELECT USING (user_id = get_user_id_from_auth_uid());
CREATE POLICY "관리자 권한" ON public.coin_point_purchase_requests FOR ALL USING (is_admin());

-- File: docker/volumes/db/init/schemas/19-challenges.sql
CREATE TABLE IF NOT EXISTS public.challenge_action_types
(
    created_at  TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at  TIMESTAMPTZ,

    action_code TEXT PRIMARY KEY,
    name        TEXT                      NOT NULL,
    description TEXT,

    is_active   BOOLEAN     DEFAULT true  NOT NULL
);

COMMENT ON TABLE public.challenge_action_types IS '챌린지 액션 타입 테이블';
COMMENT ON COLUMN public.challenge_action_types.action_code IS '액션 코드 (comment, post, reaction, download, composite)';
COMMENT ON COLUMN public.challenge_action_types.name IS '액션명';
COMMENT ON COLUMN public.challenge_action_types.description IS '액션 설명';
COMMENT ON COLUMN public.challenge_action_types.is_active IS '활성 상태';

CREATE TABLE IF NOT EXISTS public.challenge_types
(
    created_at  TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at  TIMESTAMPTZ,

    type_code   TEXT PRIMARY KEY,
    name        TEXT                      NOT NULL,
    description TEXT,

    is_active   BOOLEAN     DEFAULT true  NOT NULL
);

COMMENT ON TABLE public.challenge_types IS '챌린지 타입 테이블';
COMMENT ON COLUMN public.challenge_types.type_code IS '타입 코드 (daily, accum)';
COMMENT ON COLUMN public.challenge_types.name IS '타입명';
COMMENT ON COLUMN public.challenge_types.description IS '타입 설명';
COMMENT ON COLUMN public.challenge_types.is_active IS '활성 상태';

CREATE TABLE IF NOT EXISTS public.challenge_codes
(
    created_at  TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at  TIMESTAMPTZ,

    code        TEXT PRIMARY KEY,
    description TEXT                      NOT NULL,
    category    TEXT,

    is_active   BOOLEAN     DEFAULT true  NOT NULL
);

COMMENT ON TABLE public.challenge_codes IS '챌린지 코드 마스터 테이블';
COMMENT ON COLUMN public.challenge_codes.code IS '가독성있는 챌린지 코드 (예: D_POST_10, Q_COMMENT_10)';
COMMENT ON COLUMN public.challenge_codes.description IS '코드 설명';
COMMENT ON COLUMN public.challenge_codes.category IS '코드 카테고리 (daily, accum)';
COMMENT ON COLUMN public.challenge_codes.is_active IS '코드 활성 상태';

CREATE TABLE IF NOT EXISTS public.challenges
(
    created_at          TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at          TIMESTAMPTZ,

    id                  BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    code                TEXT                      NOT NULL REFERENCES public.challenge_codes (code) ON DELETE CASCADE,
    name                TEXT                      NOT NULL,
    type_code           TEXT                      NOT NULL REFERENCES public.challenge_types (type_code),
    action_code         TEXT                      NOT NULL REFERENCES public.challenge_action_types (action_code),

    target_count        INTEGER                   NOT NULL CHECK (target_count > 0),

    include_boards      BIGINT[],
    exclude_boards      BIGINT[],
    expire_days         INTEGER CHECK (expire_days > 0),

    reward_point        INTEGER                   NOT NULL CHECK (reward_point >= 0),
    point_code          TEXT                      NOT NULL DEFAULT 'ACTIVITY_POINT' REFERENCES public.point_codes (code),

    is_active           BOOLEAN     DEFAULT true  NOT NULL,
    sort_order          INTEGER     DEFAULT 0     NOT NULL,

    depends_on          TEXT[],

    additional_settings JSONB       DEFAULT '{}'::jsonb,

    CONSTRAINT unique_challenge_code UNIQUE (code)
);

COMMENT ON TABLE challenges IS '챌린지 마스터 테이블';
COMMENT ON COLUMN challenges.id IS '챌린지 내부 식별자';
COMMENT ON COLUMN challenges.code IS '사람이 읽기 쉬운 챌린지 코드 (예: D_POST_10, Q_COMMENT_10)';
COMMENT ON COLUMN challenges.name IS '챌린지명';
COMMENT ON COLUMN challenges.type_code IS '챌린지 타입 (daily: 일일, accum: 누적)';
COMMENT ON COLUMN challenges.action_code IS '챌린지 액션 타입';
COMMENT ON COLUMN challenges.target_count IS '목표 횟수';
COMMENT ON COLUMN challenges.include_boards IS '허용 게시판 ID 배열';
COMMENT ON COLUMN challenges.exclude_boards IS '제외 게시판 ID 배열';
COMMENT ON COLUMN challenges.expire_days IS 'N일 내 달성 기한 (누적용)';
COMMENT ON COLUMN challenges.reward_point IS '지급 포인트';
COMMENT ON COLUMN challenges.point_code IS '포인트 코드';
COMMENT ON COLUMN challenges.is_active IS '활성 상태';
COMMENT ON COLUMN challenges.sort_order IS 'UI 정렬 순서';
COMMENT ON COLUMN challenges.depends_on IS '선행 완료 챌린지 코드 배열 (복합 챌린지용)';
COMMENT ON COLUMN challenges.additional_settings IS '추가 설정 JSON';

CREATE INDEX IF NOT EXISTS idx_challenges_code ON challenges (code, is_active);

CREATE TABLE IF NOT EXISTS public.user_challenge_progress
(
    id            BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at    TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at    TIMESTAMPTZ DEFAULT now() NOT NULL,

    user_id       BIGINT                    NOT NULL DEFAULT get_user_id_from_auth_uid()
        REFERENCES public.users (id) ON DELETE CASCADE,
    challenge_id  BIGINT                    NOT NULL REFERENCES public.challenges (id) ON DELETE CASCADE,

    current_count INTEGER     DEFAULT 0     NOT NULL CHECK (current_count >= 0),
    is_claimed    BOOLEAN     DEFAULT false NOT NULL,
    claimed_at    TIMESTAMPTZ,

    progress_date DATE        DEFAULT CURRENT_DATE,

    expires_at    TIMESTAMPTZ,

    CONSTRAINT unique_user_challenge_daily UNIQUE (user_id, challenge_id, progress_date)
);

COMMENT ON TABLE user_challenge_progress IS '사용자 챌린지 진행상황 테이블';
COMMENT ON COLUMN user_challenge_progress.id IS '진행상황 ID';
COMMENT ON COLUMN user_challenge_progress.user_id IS '사용자 ID';
COMMENT ON COLUMN user_challenge_progress.challenge_id IS '챌린지 ID';
COMMENT ON COLUMN user_challenge_progress.current_count IS '현재 진행 횟수';
COMMENT ON COLUMN user_challenge_progress.is_claimed IS '보상 수령 여부';
COMMENT ON COLUMN user_challenge_progress.claimed_at IS '보상 수령 시간';
COMMENT ON COLUMN user_challenge_progress.progress_date IS '진행 날짜 (일일 챌린지용)';
COMMENT ON COLUMN user_challenge_progress.expires_at IS '챌린지 만료 시간 (누적용)';

CREATE INDEX IF NOT EXISTS idx_user_challenge_progress_user_id ON user_challenge_progress (user_id, expires_at);

-- File: docker/volumes/db/init/schemas/20-aggrements.sql
CREATE TABLE IF NOT EXISTS public.agreements
(
    code        TEXT PRIMARY KEY,
    title       TEXT                      NOT NULL,
    description TEXT                      NOT NULL,
    is_optional BOOLEAN     DEFAULT false NOT NULL,
    created_at  TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at  TIMESTAMPTZ
);

COMMENT ON TABLE public.agreements IS '사용자 동의 관리 테이블';
COMMENT ON COLUMN public.agreements.code IS '동의 코드 (Primary Key)';
COMMENT ON COLUMN public.agreements.title IS '동의 제목';
COMMENT ON COLUMN public.agreements.description IS '동의 내용';
COMMENT ON COLUMN public.agreements.is_optional IS '선택 동의 여부';
COMMENT ON COLUMN public.agreements.created_at IS '생성일시';
COMMENT ON COLUMN public.agreements.updated_at IS '수정일시';

CREATE TABLE IF NOT EXISTS public.user_agreements
(
    agreement_code TEXT                      NOT NULL REFERENCES public.agreements (code) ON DELETE CASCADE,
    user_id        BIGINT                    NOT NULL DEFAULT get_user_id_from_auth_uid() REFERENCES public.users (id) ON DELETE CASCADE,
    agreed         BOOLEAN     DEFAULT false NOT NULL,
    agreed_at      TIMESTAMPTZ DEFAULT now() NOT NULL,
    primary key (agreement_code, user_id)
);

COMMENT ON TABLE public.user_agreements IS '사용자 동의 기록 테이블';
COMMENT ON COLUMN public.user_agreements.agreement_code IS '동의 코드 (Primary Key)';
COMMENT ON COLUMN public.user_agreements.user_id IS '사용자 ID (Primary Key)';
COMMENT ON COLUMN public.user_agreements.agreed IS '동의 여부';
COMMENT ON COLUMN public.user_agreements.agreed_at IS '동의 일시';

CREATE INDEX idx_user_agreements_user_id ON public.user_agreements(user_id);

-- File: docker/volumes/db/init/schemas/89-anonymous_visitor_logs.sql
-- 익명 유저 접속 통계 테이블
CREATE TABLE IF NOT EXISTS public.anonymous_visitor_logs
(
    id          BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    session_key TEXT NOT NULL,                      -- 프론트엔드에서 생성한 브라우저 세션 키
    visit_date  DATE NOT NULL DEFAULT CURRENT_DATE, -- 접속 날짜 (KST 기준)
    client_ip   INET,                               -- 클라이언트 IP (선택적)
    user_agent  TEXT,                               -- User Agent 정보 (선택적)
    created_at  TIMESTAMPTZ   DEFAULT now() NOT NULL,

    -- 동일 세션키로 하루에 한 번만 기록되도록 제약 조건
    CONSTRAINT unique_session_daily_visit UNIQUE (session_key, visit_date)
);

-- 테이블 코멘트
COMMENT ON TABLE public.anonymous_visitor_logs IS '익명 유저 일일 접속 통계 로그';
COMMENT ON COLUMN public.anonymous_visitor_logs.id IS '로그 고유 ID';
COMMENT ON COLUMN public.anonymous_visitor_logs.session_key IS '프론트엔드 생성 브라우저 세션 키';
COMMENT ON COLUMN public.anonymous_visitor_logs.visit_date IS '접속 날짜 (KST 기준)';
COMMENT ON COLUMN public.anonymous_visitor_logs.client_ip IS '클라이언트 IP 주소';
COMMENT ON COLUMN public.anonymous_visitor_logs.user_agent IS '브라우저 User Agent';
COMMENT ON COLUMN public.anonymous_visitor_logs.created_at IS '최초 접속 시간';

-- 성능 최적화를 위한 인덱스
CREATE INDEX idx_anonymous_visitor_logs_visit_date ON public.anonymous_visitor_logs (visit_date);
CREATE INDEX idx_anonymous_visitor_logs_session_key ON public.anonymous_visitor_logs (session_key);

-- 익명 유저 접속 기록 함수
CREATE OR REPLACE FUNCTION public.anonymous_visitor_log_create(
    p_session_key TEXT
)
    RETURNS BOOLEAN
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
AS
$$
DECLARE
    v_client_ip  INET;
    v_visit_date DATE;
    v_user_agent TEXT;
BEGIN
    -- 입력값 검증
    IF p_session_key IS NULL OR LENGTH(TRIM(p_session_key)) = 0 THEN
        RAISE EXCEPTION '세션 키가 필요합니다.';
    END IF;

    -- 클라이언트 IP 추출
    v_client_ip := extract_client_ip();

    -- 한국 시간 기준 날짜 계산
    v_visit_date := (now() AT TIME ZONE 'Asia/Seoul')::DATE;

    -- 요청 헤더에서 정보 추출
    SELECT (current_setting('request.headers', true)::json ->> 'user-agent')
    INTO v_user_agent;

    -- 접속 로그 기록 (중복 시 무시)
    INSERT INTO public.anonymous_visitor_logs (session_key,
                                               visit_date,
                                               client_ip,
                                               user_agent)
    VALUES (p_session_key,
            v_visit_date,
            v_client_ip,
            v_user_agent)
    ON CONFLICT (session_key, visit_date) DO NOTHING;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        -- 에러 로깅
        RAISE LOG '익명 유저 접속 로그 기록 실패: session_key=%, error=%', p_session_key, SQLERRM;
        RETURN FALSE;
END;
$$;

COMMENT ON FUNCTION public.anonymous_visitor_log_create IS '익명 유저 접속 로그 기록 함수. 동일 세션키로 하루에 한 번만 기록됨.';

-- 시간 기반 접속자 수 조회 함수 (문법 수정)
CREATE OR REPLACE FUNCTION public.get_daily_visitor_count(
    p_hours INTEGER DEFAULT 24
)
    RETURNS INTEGER
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
AS
$$
DECLARE
    v_user_count INTEGER;
    v_anon_count INTEGER;
BEGIN
    SELECT COUNT(*)
    INTO v_user_count
    FROM public.user_attendance
    WHERE created_at >= (now() - (p_hours || ' hours')::INTERVAL);

    SELECT COUNT(DISTINCT session_key)
    INTO v_anon_count
    FROM public.anonymous_visitor_logs
    WHERE created_at >= (now() - (p_hours || ' hours')::INTERVAL);

    RETURN COALESCE(v_user_count + v_anon_count, 0);
END;
$$;

COMMENT ON FUNCTION public.get_daily_visitor_count IS '특정 시간 범위의 접속자 수 조회 함수';

-- File: docker/volumes/db/init/schemas/90-others.sql
CREATE TABLE IF NOT EXISTS public.migrations
(
    id          SERIAL PRIMARY KEY,
    version     VARCHAR(50)                            NOT NULL,
    applied_at  TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    description TEXT,
    CONSTRAINT unique_version UNIQUE (version)
);

CREATE TABLE IF NOT EXISTS public.posts_search_logs
(
    id           BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,

    -- 검색 정보
    search_query TEXT NOT NULL,                     -- 검색어
    search_type  TEXT NOT NULL DEFAULT 'all',       -- 검색 타입 ('title', 'content', 'all')
    board_id     BIGINT REFERENCES boards (id),     -- 검색한 게시판 ID (NULL이면 전체 검색)
    sort_by      TEXT          DEFAULT 'relevance', -- 정렬 방식

    -- 사용자 정보
    user_id      BIGINT REFERENCES users (id),      -- 사용자 ID (로그인한 경우)
    user_ip      INET,                              -- 사용자 IP

    -- 검색 결과 정보
    result_count INTEGER       DEFAULT 0,           -- 검색 결과 개수

    -- 메타 정보
    created_at   TIMESTAMPTZ   DEFAULT now() NOT NULL,
    user_agent   TEXT,                              -- 브라우저 정보
    referer      TEXT                               -- 참조 페이지
);

-- 인덱스 생성
CREATE INDEX idx_posts_search_logs_query ON public.posts_search_logs(search_query);
CREATE INDEX idx_posts_search_logs_user_id ON public.posts_search_logs(user_id);
CREATE INDEX idx_posts_search_logs_created_at ON public.posts_search_logs(created_at);
CREATE INDEX idx_posts_search_logs_board_id ON public.posts_search_logs(board_id);
CREATE INDEX idx_posts_search_logs_user_ip ON public.posts_search_logs(user_ip);

-- 테이블 코멘트
COMMENT ON TABLE public.posts_search_logs IS '사용자 검색어 수집 로그 테이블';
COMMENT ON COLUMN public.posts_search_logs.id IS '검색 로그 ID';
COMMENT ON COLUMN public.posts_search_logs.search_query IS '검색어';
COMMENT ON COLUMN public.posts_search_logs.search_type IS '검색 타입 (title/content/all)';
COMMENT ON COLUMN public.posts_search_logs.board_id IS '검색 대상 게시판 ID';
COMMENT ON COLUMN public.posts_search_logs.sort_by IS '정렬 방식';
COMMENT ON COLUMN public.posts_search_logs.user_id IS '검색한 사용자 ID';
COMMENT ON COLUMN public.posts_search_logs.user_ip IS '사용자 IP 주소';
COMMENT ON COLUMN public.posts_search_logs.result_count IS '검색 결과 개수';
COMMENT ON COLUMN public.posts_search_logs.created_at IS '검색 일시';
COMMENT ON COLUMN public.posts_search_logs.user_agent IS '브라우저 정보';
COMMENT ON COLUMN public.posts_search_logs.referer IS '참조 페이지';


-- =======================================
-- FUNCTIONS
-- =======================================

-- File: docker/volumes/db/init/functions/00-utility/01-generate-random-code.sql
-- 파일: 01-generate-random-code.sql
-- 설명: 랜덤 코드 생성 유틸리티 함수
-- 의존성: 없음

CREATE OR REPLACE FUNCTION generate_random_code(length integer DEFAULT 8) RETURNS text
    LANGUAGE plpgsql
AS
$$
DECLARE
    chars TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    result TEXT := '';
    chars_len INT := length(chars);
    i INT;
BEGIN
    -- 미리 계산한 문자 집합 길이를 사용하여 성능 향상
    FOR i IN 1..length LOOP
        result := result || substr(chars, 1 + floor(random() * chars_len)::int, 1);
    END LOOP;
    RETURN result;
END;
$$;


-- File: docker/volumes/db/init/functions/00-utility/03-extract-client-ip.sql
-- 설명: 요청 헤더에서 클라이언트 IP를 추출하는 함수
CREATE OR REPLACE FUNCTION extract_client_ip()
    RETURNS INET
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS $$
DECLARE
    v_headers JSON;
    v_ip_address TEXT;
    v_clean_ip TEXT;
BEGIN
    -- 요청 헤더 가져오기 (헤더가 없으면 null 반환)
    BEGIN
        v_headers := current_setting('request.headers', true)::json;
    EXCEPTION WHEN OTHERS THEN
        RETURN NULL;
    END;

    -- 여러 헤더에서 IP 주소 찾기 (우선순위 순)
    v_ip_address := COALESCE(
            v_headers->>'CF-Connecting-IP',       -- Cloudflare
            v_headers->>'True-Client-IP',         -- Cloudflare 및 기타
            v_headers->>'X-Real-IP',              -- Nginx
            v_headers->>'X-Forwarded-For',        -- 표준 프록시 헤더
            v_headers->>'X-Client-IP',            -- 일부 프록시
            v_headers->>'Forwarded-For',          -- 레거시
            v_headers->>'client-ip',              -- 일부 CDN
            v_headers->>'REMOTE_ADDR'             -- 직접 연결
                    );

    -- IP 주소가 없으면 NULL 반환
    IF v_ip_address IS NULL OR v_ip_address = '' THEN
        RETURN NULL;
    END IF;

    -- X-Forwarded-For는 여러 IP가 쉼표로 구분되어 있을 수 있음
    -- 첫 번째 IP만 사용 (클라이언트 IP)
    v_clean_ip := split_part(v_ip_address, ',', 1);

    -- 공백 제거
    v_clean_ip := trim(v_clean_ip);

    -- INET 타입으로 변환 시도
    BEGIN
        RETURN v_clean_ip::INET;
    EXCEPTION WHEN OTHERS THEN
        -- 변환 실패 시 로그 기록 및 NULL 반환
        RAISE LOG 'IP 주소 변환 실패: %', v_clean_ip;
        RETURN NULL;
    END;
END;
$$;

COMMENT ON FUNCTION extract_client_ip() IS '요청 헤더에서 클라이언트 IP 주소를 추출하여 INET 타입으로 반환하는 함수. 여러 헤더를 우선순위에 따라 확인하고, X-Forwarded-For와 같이 여러 IP가 포함된 헤더에서는 첫 번째 IP(클라이언트 IP)만 추출함.';

-- File: docker/volumes/db/init/functions/00-utility/04-auth-hooks.sql
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    STABLE
AS
$$
DECLARE
    claims    jsonb;
    user_data jsonb;
BEGIN
    -- 기본 claims 가져오기
    claims := event -> 'claims';

    -- 사용자 정보 조회 (한 번의 쿼리로 모든 필요한 정보 가져오기)
    SELECT to_jsonb(sub_query.*)
    INTO user_data
    FROM (SELECT u.id                                                                             as user_id,
                 u.nickname,
                 u.permission_type,
                 CASE WHEN u.permission_type IN ('super_admin', 'admin') THEN true ELSE false END as is_admin,
                 u.status,
                 u.created_at
          FROM public.users u
          WHERE u.auth_user_id = (event ->> 'user_id')::uuid
            AND u.deleted_at IS NULL
          LIMIT 1) sub_query;

    -- 사용자 데이터가 있으면 claims에 추가
    IF user_data IS NOT NULL THEN
        claims := claims || user_data;
    ELSE
        -- 사용자가 없으면 기본값 설정
        claims := claims || jsonb_build_object(
                'user_id', null,
                'permission_type', 'anonymous',
                'is_admin', false
                            );
    END IF;

    -- 수정된 claims 반환
    RETURN jsonb_build_object(
            'claims', claims,
            'user_id', event ->> 'user_id',
            'aud', event ->> 'aud',
            'role', event ->> 'role'
           );
END;
$$;

-- Hook 함수에 적절한 권한 부여
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook(jsonb) TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook(jsonb) TO postgres;

-- File: docker/volumes/db/init/functions/01-users/01-withdrawal.sql
-- 설명: 회원 탈퇴 처리 함수

CREATE OR REPLACE FUNCTION public.users_withdrawal(p_user_id bigint)
RETURNS void AS $$
DECLARE
    retention_days integer;
BEGIN
    -- 보관 기간 설정 조회
    SELECT value
    INTO retention_days
    FROM site_config_kv
    WHERE key = 'cleanup.days_member_leave'
    LIMIT 1;

    -- 탈퇴 요청 상태로 변경
    UPDATE users 
    SET 
        is_withdrawal_requested = true,
        status = 'pending_withdrawal',
        deleted_at = now() + (retention_days || ' days')::interval
    WHERE id = p_user_id;

    -- 포인트 만료 처리
    -- UPDATE user_point_wallets
    -- SET balance = 0
    -- WHERE user_id = p_user_id;

    -- 알림 발송 (Optional)
    -- TODO: 알림 발송 로직 추가
END;
$$ LANGUAGE plpgsql;


-- File: docker/volumes/db/init/functions/01-users/02-duplicate-checks.sql
-- 설명: 사용자 데이터 중복 체크 함수
-- 의존성: schema/02-tables/01-users.sql (users 테이블)

-- 로그인 ID 중복 체크 함수
CREATE OR REPLACE FUNCTION users_is_login_id_duplicate(p_login_id text) RETURNS boolean
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS $$
DECLARE
    exists_count integer;
BEGIN
    -- 입력값 검증
    IF p_login_id IS NULL OR p_login_id = '' THEN
        RETURN false;
    END IF;

    SELECT COUNT(*)
    INTO exists_count
    FROM public.users
    WHERE login_id = p_login_id
      AND deleted_at IS NULL;

    -- 중복이 있으면 true, 없으면 false 반환
    RETURN exists_count > 0;
END;
$$;

-- 이메일 중복 체크 함수
CREATE OR REPLACE FUNCTION users_is_email_duplicate(p_email text) RETURNS boolean
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS $$
DECLARE
    exists_count integer;
BEGIN
    -- 입력값 검증
    IF p_email IS NULL OR p_email = '' THEN
        RETURN false;
    END IF;

    SELECT COUNT(*)
    INTO exists_count
    FROM public.users
    WHERE email = p_email
      AND deleted_at IS NULL;

    -- 중복이 있으면 true, 없으면 false 반환
    RETURN exists_count > 0;
END;
$$;

-- 닉네임 중복 체크 함수
CREATE OR REPLACE FUNCTION users_is_nickname_duplicate(p_nickname text) RETURNS boolean
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS $$
DECLARE
    exists_count integer;
BEGIN
    -- 입력값 검증
    IF p_nickname IS NULL OR p_nickname = '' THEN
        RETURN false;
    END IF;

    SELECT COUNT(*)
    INTO exists_count
    FROM public.users
    WHERE LOWER(nickname) = LOWER(p_nickname)
      AND deleted_at IS NULL;

    -- 중복이 있으면 true, 없으면 false 반환
    RETURN exists_count > 0;
END;
$$;


-- File: docker/volumes/db/init/functions/01-users/03-nickname-validation.sql
-- 설명: 사용자 닉네임 변경 검증 함수

CREATE OR REPLACE FUNCTION users_nickname_change_validation(
    p_new_nickname TEXT
) RETURNS JSONB AS
$$
DECLARE
    v_user_id                       BIGINT := get_user_id_from_auth_uid();
    v_nickname_change_interval_days INTEGER;
    v_forbidden_words               TEXT[];
    v_last_changed                  TIMESTAMPTZ;
    v_nickname_exists               BOOLEAN;
    v_current_date                  TIMESTAMPTZ := now();
BEGIN
    SELECT value INTO v_nickname_change_interval_days
    FROM site_config_kv
    WHERE key = 'user.nickname_change_interval_days';

    SELECT value INTO v_forbidden_words
    FROM site_config_kv
    WHERE key = 'site.forbidden_words';

    -- 유저의 마지막 닉네임 변경일 확인
    SELECT nickname_changed_at
    INTO v_last_changed
    FROM users
    WHERE id = v_user_id;

    -- 닉네임 변경 간격 검증
    IF v_last_changed IS NOT NULL AND v_current_date - v_last_changed < (v_nickname_change_interval_days || ' days')::INTERVAL THEN
        RETURN jsonb_build_object(
                'success', FALSE,
                'message', '닉네임 변경 간격이 너무 짧습니다'
               );
    END IF;

    -- 중복 닉네임 여부 확인
    SELECT EXISTS (SELECT 1
                   FROM users
                   WHERE LOWER(nickname) = LOWER(p_new_nickname)
                     AND id != v_user_id)
    INTO v_nickname_exists;

    IF v_nickname_exists THEN
        RETURN jsonb_build_object(
                'success', FALSE,
                'message', '이미 사용 중인 닉네임입니다'
               );
    END IF;

    -- 닉네임 길이 제한
    IF length(p_new_nickname) < 2 OR length(p_new_nickname) > 20 THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'message', '닉네임은 2자 이상 20자 이하여야 합니다'
        );
    END IF;

    -- 특수문자 제한 (정규식 패턴)
    IF p_new_nickname ~ '[^a-zA-Z0-9가-힣_-]' THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'message', '닉네임은 한글, 영문, 숫자, 밑줄(_), 하이픈(-)만 사용 가능합니다'
        );
    END IF;

    -- 금칙어 포함 여부 확인
    IF EXISTS (SELECT 1
               FROM unnest(v_forbidden_words) AS forbidden_word
               WHERE POSITION(forbidden_word IN LOWER(p_new_nickname)) > 0) THEN
        RETURN jsonb_build_object(
                'success', FALSE,
                'message', '닉네임에 금칙어가 포함되어 있습니다'
               );
    END IF;

    -- 모든 검증 통과 시
    RETURN jsonb_build_object(
            'success', TRUE,
            'message', 'Valid'
           );
END;
$$ LANGUAGE plpgsql;


-- File: docker/volumes/db/init/functions/01-users/04-block-user.sql
-- 사용자 차단 함수
CREATE OR REPLACE FUNCTION public.users_block_user(
    p_blocked_user_id BIGINT,
    p_reason TEXT DEFAULT NULL
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_blocker_id BIGINT := get_user_id_from_auth_uid();
BEGIN
    -- 로그인 확인
    IF v_blocker_id IS NULL THEN
        RAISE EXCEPTION '로그인이 필요합니다.';
    END IF;

    -- 자기 자신 차단 방지
    IF v_blocker_id = p_blocked_user_id THEN
        RAISE EXCEPTION '자기 자신을 차단할 수 없습니다.';
    END IF;

    -- 차단 대상 사용자 존재 확인
    IF NOT EXISTS (SELECT 1 FROM public.users WHERE id = p_blocked_user_id AND deleted_at IS NULL) THEN
        RAISE EXCEPTION '존재하지 않는 사용자입니다.';
    END IF;

    -- 이미 차단한 사용자인지 확인
    IF EXISTS (
        SELECT 1
        FROM public.user_blocks
        WHERE blocker_user_id = v_blocker_id
          AND blocked_user_id = p_blocked_user_id
    ) THEN
        RAISE EXCEPTION '이미 차단한 사용자입니다.';
    END IF;

    -- 차단 정보 추가
    INSERT INTO public.user_blocks (
        blocker_user_id,
        blocked_user_id,
        reason
    ) VALUES (
        v_blocker_id,
        p_blocked_user_id,
        p_reason
    );

    RETURN TRUE;
EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG 'users_block_user 오류: %', SQLERRM;
        RETURN FALSE;
END;
$$;

-- 사용자 차단 해제 함수
CREATE OR REPLACE FUNCTION public.users_unblock_user(
    p_blocked_user_id BIGINT
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_blocker_id BIGINT := get_user_id_from_auth_uid();
    v_block_record RECORD;
BEGIN
    -- 로그인 확인
    IF v_blocker_id IS NULL THEN
        RAISE EXCEPTION '로그인이 필요합니다.';
    END IF;

    -- 차단 기록 확인
    SELECT * INTO v_block_record
    FROM public.user_blocks
    WHERE blocker_user_id = v_blocker_id
      AND blocked_user_id = p_blocked_user_id;

    IF v_block_record IS NULL THEN
        RAISE EXCEPTION '차단하지 않은 사용자입니다.';
    END IF;

    -- Hadr Delete 방식으로 차단 해제
    DELETE FROM public.user_blocks
    WHERE blocked_user_id = v_block_record.id;

    RETURN TRUE;
EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG 'users_unblock_user 오류: %', SQLERRM;
        RETURN FALSE;
END;
$$;

-- 현재 사용자가 특정 사용자를 차단했는지 확인하는 함수
CREATE OR REPLACE FUNCTION public.users_is_blocked_by_current_user(
    p_user_id BIGINT
)
    RETURNS BOOLEAN
    LANGUAGE plpgsql
    SECURITY DEFINER
AS $$
DECLARE
    v_current_user_id BIGINT := get_user_id_from_auth_uid();
BEGIN
    -- 익명 사용자는 차단 기능을 사용할 수 없음
    IF v_current_user_id IS NULL THEN
        RETURN FALSE;
    END IF;

    -- 현재 사용자가 특정 사용자를 차단했는지 확인
    RETURN EXISTS (
        SELECT 1
        FROM public.user_blocks
        WHERE blocker_user_id = v_current_user_id
          AND blocked_user_id = p_user_id
    );
END;
$$;

-- 현재 유저가 게시물 작성자를 차단했는지 확인
CREATE OR REPLACE FUNCTION posts_writer_is_blocked_by_current_user(posts)
    RETURNS BOOLEAN
    STABLE
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS $$
BEGIN
    RETURN users_is_blocked_by_current_user($1.writer_id);
END;
$$;

-- 댓글 작성자가 현재 사용자를 차단했는지 확인
CREATE OR REPLACE FUNCTION comments_writer_is_blocked_by_current_user(comments)
    RETURNS BOOLEAN
    STABLE
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS $$
BEGIN
    RETURN users_is_blocked_by_current_user($1.writer_id);
END;
$$;

-- File: docker/volumes/db/init/functions/01-users/05-user-attendance.sql
-- 설명: 출석체크 및 로그인 포인트 지급 함수
CREATE OR REPLACE FUNCTION public.user_attendance_process()
    RETURNS boolean
    LANGUAGE plpgsql
    SECURITY DEFINER
AS $$
DECLARE
    v_user_id BIGINT = get_user_id_from_auth_uid();
    v_today DATE := (NOW() AT TIME ZONE 'Asia/Seoul')::DATE;
    v_login_point INTEGER;
    v_point_transaction_id BIGINT;
    v_attendance_id BIGINT;
    v_attendance_exists BOOLEAN;
    v_policy_id BIGINT := 1; -- 활동 포인트 정책 ID (기본값)
BEGIN
    -- 해당 사용자가 없으면 처리하지 않음
    IF v_user_id IS NULL THEN
        RAISE LOG '출석체크: 사용자정보 조회 실패';
        RAISE EXCEPTION '사용자를 찾을 수 없습니다.';
    END IF;

    -- 오늘 이미 출석체크했는지 확인
    SELECT EXISTS (
        SELECT 1
        FROM public.user_attendance
        WHERE user_id = v_user_id
          AND attendance_date = v_today
    ) INTO v_attendance_exists;

    -- 이미 출석했으면 처리하지 않음
    IF v_attendance_exists THEN
        RAISE LOG '출석체크: 이미 처리됨 (user_id: %, date: %)', v_user_id, v_today;
        RAISE EXCEPTION '이미 출석체크를 완료했습니다.';
    END IF;

    -- 로그인 포인트 설정 가져오기
    SELECT value::INTEGER
    INTO v_login_point
    FROM public.site_config_kv
    WHERE key = 'user.login_point';

    -- 출석체크 기록 저장
    INSERT INTO public.user_attendance (user_id, attendance_date)
    VALUES (v_user_id, v_today);

    -- 출석체크 ID 조회
    SELECT id INTO v_attendance_id
    FROM public.user_attendance
    WHERE user_id = v_user_id
      AND attendance_date = v_today;

    -- 로그인 포인트가 0보다 큰 경우에만 지급
    IF v_login_point > 0 THEN
        BEGIN
            -- 포인트 지급
            PERFORM private.points_issue(
                    v_user_id,                 -- 사용자 ID
                    'ACTIVITY_POINT',          -- 포인트 코드
                    v_login_point,             -- 포인트 금액
                    v_policy_id,               -- 정책 ID
                    '출석체크 포인트'           -- 설명
                    );

            -- 지급된 포인트 트랜잭션 ID 조회
            SELECT id INTO v_point_transaction_id
            FROM public.point_transactions
            WHERE user_id = v_user_id
              AND description = '출석체크 포인트'
            ORDER BY created_at DESC
            LIMIT 1;

        EXCEPTION WHEN OTHERS THEN
            RAISE LOG '출석체크: 포인트 지급 실패 (user_id: %, error: %)', v_user_id, SQLERRM;
            -- 에러 로깅
            INSERT INTO point_error_logs (error_type,
                                          error_message,
                                          user_id,
                                          point_code,
                                          amount,
                                          table_name,
                                          table_record_id,
                                          additional_info)
            VALUES ('ISSUE',
                    SQLERRM,
                    v_user_id,
                    'ACTIVITY_POINT',
                    v_login_point,
                    'user_attendance',
                    v_attendance_id,
                    jsonb_build_object(
                            'source', 'user_attendance_process'
                    ));
        END;
    END IF;

    RAISE LOG '출석체크: 완료 (user_id: %, date: %, point: %)', v_user_id, v_today, v_login_point;

    RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
    RAISE LOG '출석체크: 처리 중 오류 발생 (user_id: %, error: %)', v_user_id, SQLERRM;
    RAISE EXCEPTION '출석체크 실패: %', SQLERRM;
END;
$$;

-- File: docker/volumes/db/init/functions/03-blocked-ips/01-is-blocked.sql
-- 설명: IP 차단 확인
-- 의존성: schema/02-tables/03-blocked-ips.sql (blocked_ips 테이블)

create or replace function public.blocked_ips_is_blocked(check_ip inet)
    returns boolean as
$$
begin
    return exists (select 1
                   from public.blocked_ips
                   where ip_address = check_ip
                     and (expires_at is null or expires_at > now()));
end;
$$ language plpgsql security definer;

-- File: docker/volumes/db/init/functions/03-blocked-ips/02-do-block.sql
-- 설명: IP 차단
-- 의존성: schema/02-tables/03-blocked-ips.sql (blocked_ips 테이블)

create or replace function public.blocked_ips_do_block(
    ip_to_block        inet,
    p_reason           text,
    p_blocked_by_user_id bigint default get_user_id_from_auth_uid() -- 기본값으로 현재 사용자 ID 사용
)
    returns void
    language plpgsql
    security definer -- 중요: 함수 내에서 다른 테이블 접근 권한 필요
    set search_path = public
as
$$
begin
    -- 관리자 권한 확인
    if not is_admin() then
        raise log 'Permission denied: Only administrators can block IPs.';
        raise exception 'Permission denied: Only administrators can block IPs.';
    end if;

    -- 기존 로직 시작
    if exists(select 1 from blocked_ips where ip_address = ip_to_block and deleted_at is null) then
        raise log 'IP address % is already blocked.', ip_to_block;
        raise exception 'IP address % is already blocked.', ip_to_block;
    end if;

    insert into blocked_ips (ip_address, reason, blocked_by_user_id)
    values (ip_to_block, p_reason, p_blocked_by_user_id);
end;
$$;

-- File: docker/volumes/db/init/functions/03-blocked-ips/03-do-unblock.sql
-- 설명: IP 차단 해제
-- 의존성: schema/02-tables/03-blocked-ips.sql (blocked_ips 테이블)

CREATE OR REPLACE FUNCTION public.blocked_ips_do_unblock(ip_to_unblock inet)
    RETURNS void
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
AS
$$
DECLARE
    v_block_record RECORD;
    -- v_current_user_id bigint := get_user_id_from_auth_uid(); -- soft delete 시 필요
BEGIN
    -- 관리자 권한 확인
    IF NOT is_admin() THEN
        RAISE LOG '관리자만 IP 차단을 해제할 수 있습니다.';
        RAISE EXCEPTION '관리자만 IP 차단을 해제할 수 있습니다.';
    END IF;

    -- 기존 로직 시작
    SELECT * INTO v_block_record FROM blocked_ips WHERE ip_address = ip_to_unblock AND deleted_at IS NULL;

    IF v_block_record IS NULL THEN
        RAISE LOG 'IP 주소 [%] 는 차단 되어있지 않습니다.', ip_to_unblock;
        RAISE EXCEPTION 'IP 주소 [%] 는 차단 되어있지 않습니다.', ip_to_unblock;
    END IF;

    -- soft delete 방식으로 변경하려면 아래 주석 해제하고 테이블 수정 필요
    -- update blocked_ips
    -- set deleted_at         = now(),
    --     unblocked_at = now(),
    --     unblocked_by_user_id = v_current_user_id
    -- where id = v_block_record.id;

    -- 현재는 hard delete 방식
     DELETE FROM blocked_ips WHERE id = v_block_record.id;

END;
$$;


-- File: docker/volumes/db/init/functions/05-posts/01-read.sql
-- 설명: 게시글 조회 처리 함수
CREATE OR REPLACE FUNCTION public.posts_read(
    p_post_id bigint,
    p_viewer_ip inet
)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
AS
$$
DECLARE
    v_viewer_id       bigint := get_user_id_from_auth_uid();
    v_board_id        bigint;
    v_current_time    timestamp with time zone;
    v_read_point_cost integer;
    v_result          jsonb;
    v_is_anonymous    boolean;
    v_read_level      integer;
    v_user_level      integer;
    v_writer_id       bigint;
    v_ip_base_view_count boolean;
    v_already_viewed  boolean := false;
BEGIN
    IF is_admin() THEN
        RETURN (SELECT to_jsonb(row)
                FROM (SELECT p.*,
                             u.avatar_path,
                             u.nickname
                      FROM public.posts p
                               INNER JOIN public.users u ON p.writer_id = u.id
                      WHERE p.id = p_post_id) row);
    END IF;

    -- 현재 시간 설정
    v_current_time := now();

    -- 익명 사용자 여부 확인
    v_is_anonymous := (v_viewer_id IS NULL);

    -- 게시글 존재 여부, 게시판 ID 및 작성자 ID 확인
    SELECT
        board_id,
        writer_id
    INTO
        v_board_id,
        v_writer_id
    FROM public.posts
    WHERE id = p_post_id
      AND posts.status = 'published'
      AND deleted_at IS NULL;

    IF NOT FOUND THEN
        RAISE LOG '존재하지 않는 게시글입니다. post_id: %', p_post_id;
        RAISE EXCEPTION '존재하지 않는 게시글입니다.';
    END IF;

    -- 작성자 본인인 경우 바로 반환
    IF v_viewer_id = v_writer_id THEN
        RETURN (SELECT to_jsonb(row)
                FROM (SELECT p.*,
                             u.avatar_path,
                             u.nickname
                      FROM public.posts p
                               INNER JOIN public.users u ON p.writer_id = u.id
                      WHERE p.id = p_post_id) row);
    END IF;

    -- 게시판의 포인트 설정 확인 및 읽기 권한 레벨 확인
    SELECT
        (point_settings->>'read_post')::integer,
        (permission_settings->>'read_level')::integer
    INTO
        v_read_point_cost,
        v_read_level
    FROM public.boards
    WHERE id = v_board_id;

    -- 익명 사용자 접근 제한
    IF v_is_anonymous AND (v_read_point_cost > 0 OR v_read_level > 0) THEN
        RAISE LOG '익명 사용자는 포인트 또는 읽기 레벨 필요한 게시글에 접근할 수 없습니다. post_id: %', p_post_id;
        RAISE EXCEPTION '해당 게시글에 접근하려면 로그인이 필요합니다.';
    END IF;

    -- 로그인 사용자인 경우 레벨 확인
    IF NOT v_is_anonymous THEN
        -- 사용자 레벨 조회
        SELECT activity_level
        INTO v_user_level
        FROM users
        WHERE id = v_viewer_id;

        -- 사용자 레벨이 읽기 레벨보다 낮은 경우 접근 제한
        IF v_user_level < v_read_level THEN
            RAISE LOG '읽기 권한이 없습니다. 사용자 레벨: %, 필요 레벨: %, post_id: %', v_user_level, v_read_level, p_post_id;
            RAISE EXCEPTION '읽기 권한이 부족합니다. 필요 레벨: %', v_read_level USING HINT = '활동을 통해 레벨을 올린 후 다시 시도해주세요.';
        END IF;
    END IF;

    -- IP 기반 조회수 설정 확인
    SELECT value INTO v_ip_base_view_count
    FROM site_config_kv
    WHERE key = 'site.enable_ip_base_view_count';

    -- 이미 조회했는지 확인 (insert-only 구조)
    IF v_is_anonymous THEN
        -- 익명 사용자: IP 기반 중복 체크
        SELECT EXISTS(
            SELECT 1 FROM public.post_views
            WHERE post_id = p_post_id
              AND viewer_ip = p_viewer_ip
              AND viewer_id IS NULL
            LIMIT 1
        ) INTO v_already_viewed;
    ELSE
        -- 로그인 사용자: 사용자 ID 기반 중복 체크
        SELECT EXISTS(
            SELECT 1 FROM public.post_views
            WHERE post_id = p_post_id
              AND viewer_id = v_viewer_id
            LIMIT 1
        ) INTO v_already_viewed;
    END IF;

    -- 조회 기록 저장 처리
    IF v_is_anonymous THEN
        -- 익명 사용자: 첫 조회인 경우에만 기록
        IF NOT v_already_viewed THEN
            INSERT INTO public.post_views (
                post_id,
                viewer_id,
                viewer_ip,
                created_at
            ) VALUES (
                         p_post_id,
                         v_viewer_id,
                         p_viewer_ip,
                         v_current_time
                     );
        END IF;
    ELSE
        -- 로그인 사용자: 매번 기록
        INSERT INTO public.post_views (
            post_id,
            viewer_id,
            viewer_ip,
            created_at
        ) VALUES (
                     p_post_id,
                     v_viewer_id,
                     p_viewer_ip,
                     v_current_time
                 );
    END IF;

    -- 조회수 증가 처리
    IF v_ip_base_view_count THEN
        -- IP 기반 조회수 기능이 켜져 있을 때: 첫 조회인 경우에만 증가
        IF NOT v_already_viewed THEN
            UPDATE public.posts
            SET view_count = COALESCE(view_count, 0) + 1,
                updated_at = v_current_time
            WHERE id = p_post_id;
        END IF;
    ELSE
        -- IP 기반 조회수 기능이 꺼져 있을 때: 매번 증가
        UPDATE public.posts
        SET view_count = COALESCE(view_count, 0) + 1,
            updated_at = v_current_time
        WHERE id = p_post_id;
    END IF;

    IF NOT v_is_anonymous AND v_read_point_cost > 0 AND NOT v_already_viewed THEN
        BEGIN
            PERFORM private.points_use(
                    v_viewer_id,
                    'ACTIVITY_POINT',
                    v_read_point_cost,
                    format('게시물 조회 포인트 차감: 게시물 #%s)', p_post_id)
                    );
        EXCEPTION
            WHEN OTHERS THEN
                RAISE LOG '게시글 조회 포인트 차감 실패: user_id=%, amount=%, error=%', v_viewer_id, v_read_point_cost, SQLERRM;
                RAISE EXCEPTION '포인트 차감 중 오류가 발생했습니다. 다시 시도해 주세요.';
        END;
    END IF;

    -- 게시글 정보 조회 및 반환
    SELECT to_jsonb(row) INTO v_result
    FROM (SELECT p.*,
                 u.avatar_path,
                 u.nickname
          FROM public.posts p
                   INNER JOIN public.users u ON p.writer_id = u.id
          WHERE p.id = p_post_id) row;

    IF v_result IS NULL THEN
        RAISE LOG '게시글 정보를 조회할 수 없습니다. post_id: %', p_post_id;
        RAISE EXCEPTION '게시글을 조회할 수 없습니다.';
    END IF;

    RETURN v_result;
END;
$$;

-- File: docker/volumes/db/init/functions/05-posts/02-search.sql
-- 설명: pgroonga를 사용한 게시물 검색 기능 구현
-- 의존성: 
--   schema/02-tables/05-posts.sql (posts 테이블)
--   extensions.sql (pgroonga 확장)

-- 제목 검색 함수
CREATE OR REPLACE FUNCTION posts_search_by_title(
    p_query TEXT,
    p_board_id BIGINT DEFAULT NULL,
    p_page_number INTEGER DEFAULT 20,
    p_page_size INTEGER DEFAULT 0,
    p_sort_by TEXT DEFAULT 'relevance' -- 'relevance', 'latest', 'views', 'likes'
)
    RETURNS TABLE
            (
                id            BIGINT,
                board_id      BIGINT,
                title         TEXT,
                content       TEXT,
                writer_name   TEXT,
                created_at    TIMESTAMPTZ,
                view_count    INTEGER,
                comment_count INTEGER,
                like_count    INTEGER,
                is_notice     BOOLEAN,
                score         FLOAT
            )
    SECURITY DEFINER
    SET search_path = public, extensions
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
        SELECT p.id,
               p.board_id,
               p.title,
               p.content,
               p.writer_name,
               p.created_at,
               p.view_count,
               p.comment_count,
               p.like_count,
               p.is_notice,
               pgroonga_score(p.tableoid, p.ctid)::float AS score
        FROM public.posts p
        WHERE p.deleted_at IS NULL
          AND (p_board_id IS NULL OR p.board_id = p_board_id)
          AND p.title &@~ p_query
        ORDER BY
            p.is_notice DESC,
            CASE
                WHEN p_sort_by = 'latest' THEN NULL
                WHEN p_sort_by = 'views' THEN NULL
                WHEN p_sort_by = 'likes' THEN NULL
                ELSE pgroonga_score(p.tableoid, p.ctid)::float
            END DESC,
            CASE
                WHEN p_sort_by = 'latest' THEN p.created_at
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'views' THEN p.view_count
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'likes' THEN p.like_count
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'relevance' THEN p.created_at
                ELSE NULL
            END DESC
        LIMIT p_page_number OFFSET p_page_size;
END;
$$;

-- 2-2. 내용 검색 함수
CREATE OR REPLACE FUNCTION posts_search_by_content(
    p_query TEXT,
    p_board_id BIGINT DEFAULT NULL,
    p_page_number INTEGER DEFAULT 20,
    p_page_size INTEGER DEFAULT 0,
    p_sort_by TEXT DEFAULT 'relevance' -- 'relevance', 'latest', 'views', 'likes'
)
    RETURNS TABLE
            (
                id            BIGINT,
                board_id      BIGINT,
                title         TEXT,
                content       TEXT,
                writer_name   TEXT,
                created_at    TIMESTAMPTZ,
                view_count    INTEGER,
                comment_count INTEGER,
                like_count    INTEGER,
                is_notice     BOOLEAN,
                score         FLOAT
            )
    SECURITY DEFINER
    SET search_path = public, extensions
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
        SELECT p.id,
               p.board_id,
               p.title,
               p.content,
               p.writer_name,
               p.created_at,
               p.view_count,
               p.comment_count,
               p.like_count,
               p.is_notice,
               pgroonga_score(p.tableoid, p.ctid)::float AS score
        FROM public.posts p
        WHERE p.deleted_at IS NULL
          AND (p_board_id IS NULL OR p.board_id = p_board_id)
          AND p.content &@~ p_query
        ORDER BY
            p.is_notice DESC,
            CASE
                WHEN p_sort_by = 'latest' THEN NULL
                WHEN p_sort_by = 'views' THEN NULL
                WHEN p_sort_by = 'likes' THEN NULL
                ELSE pgroonga_score(p.tableoid, p.ctid)::float
            END DESC,
            CASE
                WHEN p_sort_by = 'latest' THEN p.created_at
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'views' THEN p.view_count
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'likes' THEN p.like_count
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'relevance' THEN p.created_at
                ELSE NULL
            END DESC
        LIMIT p_page_number OFFSET p_page_size;
END;
$$;

-- 2-3. 제목 + 내용 검색 함수
CREATE OR REPLACE FUNCTION posts_search_by_title_and_content(
    p_query TEXT,
    p_board_id BIGINT DEFAULT NULL,
    p_page_number INTEGER DEFAULT 20,
    p_page_size INTEGER DEFAULT 0,
    p_sort_by TEXT DEFAULT 'relevance' -- 'relevance', 'latest', 'views', 'likes'
)
    RETURNS TABLE
            (
                id            BIGINT,
                board_id      BIGINT,
                title         TEXT,
                content       TEXT,
                writer_name   TEXT,
                created_at    TIMESTAMPTZ,
                view_count    INTEGER,
                comment_count INTEGER,
                like_count    INTEGER,
                is_notice     BOOLEAN,
                score         FLOAT
            )
    SECURITY DEFINER
    SET search_path = public, extensions
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
        SELECT p.id,
               p.board_id,
               p.title,
               p.content,
               p.writer_name,
               p.created_at,
               p.view_count,
               p.comment_count,
               p.like_count,
               p.is_notice,
               pgroonga_score(p.tableoid, p.ctid)::float AS score
        FROM public.posts p
        WHERE p.deleted_at IS NULL
          AND (p_board_id IS NULL OR p.board_id = p_board_id)
          AND (p.title &@~ p_query OR p.content &@~ p_query)
        ORDER BY
            p.is_notice DESC,
            CASE
                WHEN p_sort_by = 'latest' THEN NULL
                WHEN p_sort_by = 'views' THEN NULL
                WHEN p_sort_by = 'likes' THEN NULL
                ELSE pgroonga_score(p.tableoid, p.ctid)::float
            END DESC,
            CASE
                WHEN p_sort_by = 'latest' THEN p.created_at
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'views' THEN p.view_count
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'likes' THEN p.like_count
                ELSE NULL
            END DESC,
            CASE
                WHEN p_sort_by = 'relevance' THEN p.created_at
                ELSE NULL
            END DESC
        LIMIT p_page_number OFFSET p_page_size;
END;
$$;

-- 2-4. 통합 검색 함수 (검색 타입을 매개변수로 받는)
CREATE OR REPLACE FUNCTION posts_search(
    p_query TEXT,
    p_search_type TEXT DEFAULT 'all', -- 'title', 'content', 'all'
    p_board_id BIGINT DEFAULT NULL,
    p_page_number INTEGER DEFAULT 20,
    p_page_size INTEGER DEFAULT 0,
    p_sort_by TEXT DEFAULT 'relevance' -- 'relevance', 'latest', 'views', 'likes'
)
    RETURNS TABLE
            (
                id            BIGINT,
                board_id      BIGINT,
                title         TEXT,
                content       TEXT,
                writer_name   TEXT,
                created_at    TIMESTAMPTZ,
                view_count    INTEGER,
                comment_count INTEGER,
                like_count    INTEGER,
                is_notice     BOOLEAN,
                score         FLOAT
            )
    SECURITY DEFINER
    SET search_path = public, extensions
    LANGUAGE plpgsql

AS
$$
DECLARE
    v_user_id BIGINT := get_user_id_from_auth_uid();
    v_user_ip INET := extract_client_ip();
    v_result_count INTEGER;
BEGIN
    CASE p_search_type
        WHEN 'title' THEN
            RETURN QUERY SELECT * FROM posts_search_by_title(p_query, p_board_id, p_page_number, p_page_size, p_sort_by);
            GET DIAGNOSTICS v_result_count = ROW_COUNT;
        WHEN 'content' THEN
            RETURN QUERY SELECT * FROM posts_search_by_content(p_query, p_board_id, p_page_number, p_page_size, p_sort_by);
            GET DIAGNOSTICS v_result_count = ROW_COUNT;
        ELSE -- 'all' 또는 다른 값
        RETURN QUERY SELECT * FROM posts_search_by_title_and_content(p_query, p_board_id, p_page_number, p_page_size, p_sort_by);
        GET DIAGNOSTICS v_result_count = ROW_COUNT;
        END CASE;
    -- 함수 종료 전에 추가할 INSERT 구문:
    BEGIN
        INSERT INTO public.posts_search_logs (
            search_query,
            search_type,
            board_id,
            sort_by,
            user_id,
            user_ip,
            result_count
        ) VALUES (
                     p_query,
                     p_search_type,
                     p_board_id,
                     p_sort_by,
                     v_user_id,
                     v_user_ip,
                     v_result_count
                 );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE LOG '검색 로그 기록 중 오류 발생: %', SQLERRM;
    END;
END;
$$;

-- 3. 검색 결과 총 개수 반환 함수
CREATE OR REPLACE FUNCTION posts_search_count(
    p_query TEXT,
    p_search_type TEXT DEFAULT 'all', -- 'title', 'content', 'all'
    p_board_id BIGINT DEFAULT NULL
)
    RETURNS INTEGER
    SECURITY DEFINER
    SET search_path = public, extensions
    LANGUAGE plpgsql
AS
$$
DECLARE
    total_count INTEGER;
BEGIN
    CASE p_search_type
        WHEN 'title' THEN SELECT COUNT(*)
                          INTO total_count
                          FROM public.posts p
                          WHERE p.deleted_at IS NULL
                            AND (p_board_id IS NULL OR p.board_id = p_board_id)
                            AND p.title &@~ p_query;
        WHEN 'content' THEN SELECT COUNT(*)
                            INTO total_count
                            FROM public.posts p
                            WHERE p.deleted_at IS NULL
                              AND (p_board_id IS NULL OR p.board_id = p_board_id)
                              AND p.content &@~ p_query;
        ELSE -- 'all' 또는 다른 값
        SELECT COUNT(*)
        INTO total_count
        FROM public.posts p
        WHERE p.deleted_at IS NULL
          AND (p_board_id IS NULL OR p.board_id = p_board_id)
          AND (p.title &@~ p_query OR p.content &@~ p_query);
        END CASE;

    RETURN total_count;
END;
$$;

COMMENT ON FUNCTION posts_search IS '게시물 검색 함수. search_type: title(제목), content(내용), all(전체), sort_by: relevance(관련성), latest(최신순), views(조회수), likes(추천순)';
COMMENT ON FUNCTION posts_search_count IS '검색 결과 개수를 반환하는 함수';


-- File: docker/volumes/db/init/functions/05-posts/03-check-post-read-condition.sql
-- 설명: 게시글 조회 시 게시글 조회 조건을 확인하는 함수
-- 응답:
-- READABLE: 조회 가능
-- POINT_REQUIRED: 포인트 필요
-- NOT_FOUND: 게시글 없음
CREATE OR REPLACE FUNCTION public.posts_check_read_condition(
    p_post_id bigint
)
    RETURNS text
    LANGUAGE plpgsql
    SECURITY DEFINER
AS
$$
DECLARE
    v_user_id         bigint := get_user_id_from_auth_uid();
    v_board_id        bigint;
    v_read_point_cost integer;
    v_writer_id       bigint;
    v_is_writer       boolean;
    v_is_admin        boolean;
BEGIN
    -- 관리자 여부 확인
    v_is_admin := public.is_admin();

    -- 관리자는 항상 포인트 없이 조회 가능
    IF v_is_admin THEN
        RETURN 'READABLE';
    END IF;

    -- 게시글 존재 여부, 게시판 ID 및 작성자 ID 확인
    SELECT
        board_id,
        writer_id
    INTO
        v_board_id,
        v_writer_id
    FROM public.posts
    WHERE id = p_post_id
      AND posts.status = 'published'
      AND deleted_at IS NULL;

    IF NOT FOUND THEN
        RETURN 'NOT_FOUND';
    END IF;

    -- 작성자 여부 확인
    v_is_writer := (v_user_id = v_writer_id);

    -- 작성자는 포인트 없이 조회 가능
    IF v_is_writer THEN
        RETURN 'READABLE';
    END IF;

    -- 게시판의 포인트 설정 확인
    SELECT (point_settings->>'read_post')::integer
    INTO v_read_point_cost
    FROM public.boards
    WHERE id = v_board_id;

    -- 포인트 필요 여부 반환 (0보다 크면 포인트 필요)
    IF v_read_point_cost > 0 THEN
        RETURN 'POINT_REQUIRED';
    ELSE
        RETURN 'READABLE';
    END IF;
END;
$$;

-- File: docker/volumes/db/init/functions/05-posts/04-delete.sql
CREATE OR REPLACE FUNCTION posts_delete(
    p_post_id BIGINT
)
    RETURNS boolean

AS $$
BEGIN
    UPDATE public.posts
    SET deleted_at = now(),
        status = 'deleted'
    WHERE id = p_post_id
      AND deleted_at IS NULL;

    RAISE LOG '게시글 삭제: post_id=%, deleted_at=%, deleted_by=%', p_post_id, now(), get_user_id_from_auth_uid();
    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- File: docker/volumes/db/init/functions/05-posts/05-posts-for-dashboard.sql
CREATE OR REPLACE FUNCTION public.posts_get_dashboard_recent(
    p_board_ids bigint[] DEFAULT NULL,
    p_limit_per_board integer DEFAULT 5
)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
AS
$$
DECLARE
    v_user_id bigint := get_user_id_from_auth_uid();
    v_result  jsonb;
BEGIN
    -- 파라미터 검증
    IF p_board_ids IS NULL OR array_length(p_board_ids, 1) = 0 THEN
        RAISE LOG '대시보드 게시물 조회: board_ids가 비어있습니다. user_id: %', v_user_id;
        RAISE EXCEPTION '조회할 게시판을 선택해주세요.';
    END IF;

    IF p_limit_per_board <= 0 OR p_limit_per_board > 20 THEN
        RAISE LOG '대시보드 게시물 조회: 잘못된 limit 값입니다. limit: %, user_id: %', p_limit_per_board, v_user_id;
        RAISE EXCEPTION '게시판당 조회할 게시물 수는 1~20개 사이여야 합니다.';
    END IF;

    -- 단일 쿼리로 모든 게시판의 최신 게시물 조회
    WITH accessible_boards AS (
        -- 접근 가능한 게시판 필터링
        SELECT b.id,
               b.name,
               b.visibility,
               (b.permission_settings ->> 'list_level')::integer as list_level
        FROM boards b
        WHERE b.id = ANY (p_board_ids)
          AND b.is_active = true
          AND b.deleted_at IS NULL
          AND b.visibility = 'public'),
         ranked_posts AS (
             -- 각 게시판별로 최신 게시물 순위 매기기
             SELECT p.id,
                    p.board_id,
                    p.title,
                    p.content,
                    p.writer_id,
                    p.created_at,
                    p.view_count,
                    p.comment_count,
                    p.like_count,
                    p.is_notice,
                    p.metadata,
                    ab.name as board_name,
                    ROW_NUMBER() OVER (
                        PARTITION BY p.board_id
                        ORDER BY
                            CASE WHEN p.is_notice THEN 0 ELSE 1 END,
                            p.created_at DESC
                        )   as rn
             FROM posts p
                      INNER JOIN accessible_boards ab ON p.board_id = ab.id
             WHERE p.deleted_at IS NULL
               AND p.status = 'published'
               AND p.is_secret = false),
         filtered_posts AS (
             -- 게시판별 제한 개수 적용
             SELECT *
             FROM ranked_posts
             WHERE rn <= p_limit_per_board)

    -- 최종 결과를 게시판별로 그룹화하여 JSON 구조로 변환
    SELECT COALESCE(
                   jsonb_agg(
                           jsonb_build_object(
                                   'board_id', board_id,
                                   'board_name', board_name,
                                   'posts', posts_array
                           )
                           ORDER BY board_id
                   ),
                   '[]'::jsonb
           )
    INTO v_result
    FROM (SELECT fp.board_id,
                 fp.board_name,
                 jsonb_agg(
                         jsonb_build_object(
                                 'id', fp.id,
                                 'board_id', fp.board_id,
                                 'title', fp.title,
                                 'content', LEFT(fp.content, 30),
                                 'writer_id', fp.writer_id,
                                 'created_at', fp.created_at,
                                 'view_count', fp.view_count,
                                 'comment_count', fp.comment_count,
                                 'like_count', fp.like_count,
                                 'is_notice', fp.is_notice,
                                 'metadata', fp.metadata
                         )
                         ORDER BY fp.rn
                 ) as posts_array
          FROM filtered_posts fp
          GROUP BY fp.board_id, fp.board_name) board_groups;

    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG '대시보드 게시물 조회 오류: board_ids=%, user_id=%, error=%',
            p_board_ids, v_user_id, SQLERRM;
        RAISE EXCEPTION '대시보드 게시물을 불러오는 중 오류가 발생했습니다.';
END;
$$;

COMMENT ON FUNCTION public.posts_get_dashboard_recent IS '대시보드용 게시판별 최신 게시물 목록 조회 함수';

-- File: docker/volumes/db/init/functions/05-posts/06-create.sql
CREATE OR REPLACE FUNCTION public.posts_create(
    p_board_id BIGINT,
    p_title TEXT,
    p_content TEXT,
    p_category_id BIGINT DEFAULT NULL,
    p_parent_id BIGINT DEFAULT NULL,
    p_attachments JSONB DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL,
    p_restrict_attachments JSONB DEFAULT '[]'::jsonb,
    p_password TEXT DEFAULT NULL,
    p_is_notice BOOLEAN DEFAULT FALSE,
    p_is_secret BOOLEAN DEFAULT FALSE,
    p_is_anonymous BOOLEAN DEFAULT FALSE,
    p_anonymous_nickname TEXT DEFAULT NULL,
    p_download_point INTEGER DEFAULT NULL
) RETURNS BIGINT
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public, private
AS $$
DECLARE
    v_user_id BIGINT := get_user_id_from_auth_uid();
    v_last_post_time TIMESTAMPTZ;
    v_time_limit INTERVAL := '30 seconds'; -- 기본 제한 시간 30초
    v_time_remaining INTERVAL;
    v_write_level INTEGER;
    v_forbidden_words TEXT[];
    v_today_post_count INTEGER;
    v_daily_post_limit INTEGER;
    v_user_data RECORD;
    v_post_id BIGINT;
    v_current_time TIMESTAMPTZ := now();
    v_writer_name TEXT;
    v_writer_ip INET := extract_client_ip();
BEGIN
    -- 입력 검증
    IF p_title IS NULL OR trim(p_title) = '' THEN
        RAISE EXCEPTION '제목을 입력해주세요.';
    END IF;

    IF p_content IS NULL OR trim(p_content) = '' THEN
        RAISE EXCEPTION '내용을 입력해주세요.';
    END IF;

    -- 내용 글자수 체크
    IF LENGTH(p_content) < 5 THEN
        RAISE EXCEPTION '내용은 5자 이상 작성해주세요.';
    END IF;

    IF p_board_id IS NULL THEN
        RAISE EXCEPTION '게시판 ID가 필요합니다.';
    END IF;

    -- 게시판 존재 확인
    IF NOT EXISTS (SELECT 1 FROM public.boards WHERE id = p_board_id) THEN
        RAISE EXCEPTION '존재하지 않는 게시판입니다.';
    END IF;

    -- 익명 게시글 처리
    IF p_is_anonymous THEN
        IF p_anonymous_nickname IS NULL OR length(trim(p_anonymous_nickname)) < 1 THEN
            RAISE EXCEPTION '익명 게시글 작성 시 닉네임이 필요합니다.';
        END IF;
        v_writer_name := p_anonymous_nickname; -- 표시명은 익명 닉네임 사용
    ELSE
        
        -- 인증된 사용자 정보 확인
        IF v_user_id IS NULL THEN
            RAISE EXCEPTION '로그인이 필요합니다.';
        END IF;

        SELECT u.permission_type, u.activity_level, u.nickname
        INTO v_user_data
        FROM public.users u
        WHERE u.id = v_user_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION '사용자를 찾을 수 없습니다.';
        END IF;

        v_writer_name := v_user_data.nickname;
    END IF;

    -- 게시판 설정 조회
    SELECT
        (b.permission_settings->>'write_level')::INTEGER,
        ARRAY(SELECT jsonb_array_elements_text(b.feature_settings->'forbidden_words'))
    INTO v_write_level, v_forbidden_words
    FROM boards b
    WHERE b.id = p_board_id;

    -- 금지어 체크
    IF v_forbidden_words IS NOT NULL AND array_length(v_forbidden_words, 1) > 0 THEN
        IF EXISTS (SELECT 1
                   FROM unnest(v_forbidden_words) AS fw(word)
                   WHERE fw.word IS NOT NULL
                     AND LENGTH(TRIM(fw.word)) > 0
                     AND (POSITION(LOWER(fw.word) IN LOWER(p_title)) > 0
                       OR POSITION(LOWER(fw.word) IN LOWER(p_content)) > 0)
        ) THEN
            RAISE EXCEPTION '게시글에 금칙어가 포함되어 있습니다.';
        END IF;
    END IF;

    -- 인증된 사용자의 경우 권한 및 제한 확인
    IF v_user_id IS NOT NULL THEN
        -- 관리자 및 모더레이터는 제한 없음
        IF NOT (is_admin()) THEN
            -- 글쓰기 권한 레벨 확인
            IF COALESCE(v_user_data.activity_level, 0) < COALESCE(v_write_level, 2) THEN
                RAISE EXCEPTION '게시판 글쓰기 권한이 없습니다. (레벨: %, 필요 레벨: %)', v_user_data.activity_level, v_write_level;
            END IF;

            -- 하루 게시글 작성 제한 체크
            SELECT daily_post_limit
            INTO v_daily_post_limit
            FROM public.user_level_configs
            WHERE level = v_user_data.activity_level;

            -- 기본 제한값 설정 (레벨 설정이 없을 경우)
            IF v_daily_post_limit IS NULL THEN
                v_daily_post_limit := 5; -- 기본값
            END IF;

            -- 오늘 작성한 게시글 수 조회
            SELECT COUNT(*) INTO v_today_post_count
            FROM public.posts
            WHERE writer_id = v_user_id
              AND deleted_at IS NULL
              AND created_at >= CURRENT_DATE
              AND created_at < CURRENT_DATE + INTERVAL '1 day';

            -- 하루 게시글 작성 제한 체크
            IF v_today_post_count >= v_daily_post_limit THEN
                RAISE EXCEPTION '하루 게시글 작성 제한 초과: 레벨 %은(는) 하루 최대 %개의 게시글만 작성할 수 있습니다.', v_user_data.activity_level, v_daily_post_limit;
            END IF;

            -- 마지막 게시물 이후 시간 제한 체크
            SELECT created_at INTO v_last_post_time
            FROM public.posts
            WHERE writer_id = v_user_id
              AND deleted_at IS NULL
            ORDER BY created_at DESC
            LIMIT 1;

            IF v_last_post_time IS NOT NULL AND v_current_time < v_last_post_time + v_time_limit THEN
                v_time_remaining := (v_last_post_time + v_time_limit) - v_current_time;
                RAISE EXCEPTION '게시물 작성 간격 제한: 다음 게시물을 작성하기까지 %분 %초 남았습니다.',
                    EXTRACT(MINUTE FROM v_time_remaining),
                    ROUND(EXTRACT(SECOND FROM v_time_remaining));
            END IF;
        END IF;

        -- 공지사항은 관리자만 작성 가능
        IF p_is_notice AND NOT (is_admin()) THEN
            RAISE EXCEPTION '공지사항은 관리자만 작성할 수 있습니다.';
        END IF;
    END IF;

    -- 게시글 삽입
    INSERT INTO public.posts (
        board_id,
        category_id,
        parent_id,
        writer_id,
        writer_name,
        writer_ip,
        title,
        content,
        attachments,
        metadata,
        restrict_attachments,
        password,
        is_notice,
        is_secret,
        is_anonymous,
        download_point,
        created_at,
        updated_at
    ) VALUES (
        p_board_id,
        p_category_id,
        p_parent_id,
        v_user_id,
        v_writer_name,
        v_writer_ip,
        p_title,
        p_content,
        p_attachments,
        p_metadata,
        COALESCE(p_restrict_attachments, '[]'::jsonb),
        p_password,
        COALESCE(p_is_notice, FALSE),
        COALESCE(p_is_secret, FALSE),
        COALESCE(p_is_anonymous, FALSE),
        p_download_point,
        v_current_time,
        v_current_time
    )
    RETURNING id INTO v_post_id;

    -- 챌린지 진행도 업데이트 (인증된 사용자만)
    IF v_user_id IS NOT NULL THEN
        BEGIN
            PERFORM private.user_challenge_progress_increment(
                p_user_id := v_user_id,
                p_action_code := 'post',
                p_board_id := p_board_id
            );
        EXCEPTION WHEN OTHERS THEN
            -- 챌린지 업데이트 실패해도 게시글 생성은 성공으로 처리
            -- 로그만 남기고 진행
            RAISE WARNING '챌린지 진행도 업데이트 실패: %', SQLERRM;
        END;
    END IF;

    RETURN v_post_id;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '게시글 작성 실패: %', SQLERRM;
END;
$$;

-- File: docker/volumes/db/init/functions/06-comments/01-create.sql
CREATE OR REPLACE FUNCTION public.comments_create(
    p_post_id BIGINT,
    p_content TEXT,
    p_parent_id BIGINT DEFAULT NULL,
    p_anonymous_nickname TEXT DEFAULT NULL
) RETURNS BIGINT
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public, private
AS $$
DECLARE
    v_user_id BIGINT := get_user_id_from_auth_uid();
    v_last_comment_time TIMESTAMPTZ;
    v_time_limit INTERVAL := '15 seconds'; -- 기본 제한 시간 15초
    v_time_remaining INTERVAL;
    v_comment_level INTEGER;
    v_board_id BIGINT;
    v_user_data RECORD;
    v_comment_id BIGINT;
    v_current_time TIMESTAMPTZ := now();
    v_nickname TEXT;
BEGIN
    -- 입력 검증
    IF length(p_content) < 1 THEN
        RAISE EXCEPTION '댓글 내용은 1자 이상 작성해주세요.';
    END IF;

    IF p_post_id IS NULL THEN
        RAISE EXCEPTION '게시글 ID가 필요합니다.';
    END IF;

    -- 익명 댓글 처리
    IF v_user_id IS NULL THEN
        IF p_anonymous_nickname IS NULL OR length(trim(p_anonymous_nickname)) < 1 THEN
            RAISE EXCEPTION '익명 댓글 작성 시 닉네임이 필요합니다.';
        END IF;
        v_nickname := p_anonymous_nickname;
    ELSE
        -- 사용자 권한 및 활동 레벨 확인
        SELECT u.permission_type, u.activity_level, u.nickname
        INTO v_user_data
        FROM public.users u
        WHERE u.id = v_user_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION '사용자를 찾을 수 없습니다.';
        END IF;

        v_nickname := v_user_data.nickname;
    END IF;

    -- 댓글이 작성되는 게시글의 게시판 ID 조회
    SELECT p.board_id INTO v_board_id
    FROM public.posts p
    WHERE p.id = p_post_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION '게시글을 찾을 수 없습니다.';
    END IF;

    -- 게시판의 댓글 작성 권한 레벨 조회
    SELECT (b.permission_settings->>'comment_level')::INTEGER
    INTO v_comment_level
    FROM boards b
    WHERE b.id = v_board_id;

    -- 인증된 사용자의 경우 권한 및 제한 시간 확인
    IF v_user_id IS NOT NULL AND NOT is_admin() THEN
        -- 사용자의 레벨이 comment_level보다 낮은 경우 권한 없음
        IF COALESCE(v_user_data.activity_level, 0) < COALESCE(v_comment_level, 2) THEN
            RAISE EXCEPTION '댓글 작성 권한이 없습니다. (레벨: %, 필요 레벨: %)', v_user_data.activity_level, v_comment_level;
        END IF;

        -- 해당 사용자의 마지막 댓글 작성 시간 확인
        SELECT created_at INTO v_last_comment_time
        FROM public.comments
        WHERE writer_id = v_user_id
          AND deleted_at IS NULL
        ORDER BY created_at DESC
        LIMIT 1;

        -- 마지막 댓글 작성 후 제한 시간이 지났는지 확인
        IF v_last_comment_time IS NOT NULL AND
           v_current_time < v_last_comment_time + v_time_limit THEN

            v_time_remaining := (v_last_comment_time + v_time_limit) - v_current_time;

            RAISE EXCEPTION '댓글 작성 간격 제한: 다음 댓글을 작성하기까지 %분 %초 남았습니다.',
                EXTRACT(MINUTE FROM v_time_remaining),
                ROUND(EXTRACT(SECOND FROM v_time_remaining));
        END IF;
    END IF;

    -- 댓글 삽입
    INSERT INTO public.comments (
        post_id,
        writer_id,
        writer_ip,
        content,
        parent_id,
        writer_name
    ) VALUES (
                 p_post_id,
                 v_user_id,
                 extract_client_ip(),
                 p_content,
                 p_parent_id,
                 v_nickname
             )
    RETURNING id INTO v_comment_id;

    -- 챌린지 진행도 업데이트 (인증된 사용자만)
    IF v_user_id IS NOT NULL THEN
        BEGIN
            PERFORM private.user_challenge_progress_increment(
                    p_user_id := v_user_id,
                    p_action_code := 'comment',
                    p_board_id := v_board_id
                    );
        EXCEPTION WHEN OTHERS THEN
            -- 챌린지 업데이트 실패해도 댓글 생성은 성공으로 처리
            -- 로그만 남기고 진행
            RAISE WARNING '챌린지 진행도 업데이트 실패: %', SQLERRM;
        END;
    END IF;

    RETURN v_comment_id;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '댓글 작성 실패: %', SQLERRM;
END;
$$;

COMMENT ON FUNCTION public.comments_create(BIGINT, TEXT, BIGINT, TEXT) IS '댓글 생성 함수 (보안 검증 포함)';

-- File: docker/volumes/db/init/functions/07-files/01-exist-check-history.sql
-- 사용자가 해당 파일에 대한 유효한 다운로드 기록이 있는지 확인

CREATE OR REPLACE FUNCTION public.file_download_history_get_exist(
    p_file_path TEXT
)
    RETURNS JSONB
    LANGUAGE plpgsql
AS
$$
DECLARE
    v_user_id BIGINT := get_user_id_from_auth_uid();
BEGIN
    IF v_user_id IS NULL THEN
        RETURN NULL;
    END IF;

    RETURN (SELECT to_jsonb(fdh.*)
            FROM public.file_download_histories fdh
            WHERE file_path = p_file_path
              AND user_id = v_user_id
              AND expires_at > now());
END;
$$;

COMMENT ON FUNCTION public.file_download_history_get_exist IS '사용자가 해당 파일에 대한 유효한 다운로드 링크를 가지고 있는지 확인';

CREATE OR REPLACE FUNCTION public.post_download_history_get_exist(
    p_post_id BIGINT
)
    RETURNS JSONB
    LANGUAGE plpgsql
    SECURITY DEFINER
AS
$$
DECLARE
    v_user_id BIGINT := get_user_id_from_auth_uid();
BEGIN
    -- 로그인 확인
    IF v_user_id IS NULL THEN
        RETURN NULL;
    END IF;

    -- 유효한 다운로드 이력 조회 (만료되지 않은 이력만)
    RETURN (SELECT to_jsonb(pdh.*)
            FROM public.post_download_histories pdh
            WHERE pdh.post_id = p_post_id
              AND pdh.user_id = v_user_id
              AND pdh.expires_at > now());
END;
$$;

COMMENT ON FUNCTION public.post_download_history_get_exist IS '사용자가 해당 게시물에 대한 유효한 다운로드 이력을 가지고 있는지 확인';


-- File: docker/volumes/db/init/functions/07-files/02-create-history.sql
-- 파일 다운로드 기록 생성 및 포인트 차감 함수
CREATE OR REPLACE FUNCTION public.file_download_history_create(
    p_file_path TEXT,
    p_download_url TEXT,
    p_expires_at TIMESTAMPTZ,
    p_board_id BIGINT DEFAULT NULL
)
    RETURNS JSONB
    LANGUAGE plpgsql
    SECURITY DEFINER
AS
$$
DECLARE
    v_user_id        BIGINT  := get_user_id_from_auth_uid();
    v_point_amount   INTEGER := 0;
    v_board_settings JSONB;
BEGIN
    -- 로그인 확인
    IF v_user_id IS NULL THEN
        RAISE LOG '로그인이 필요합니다. user_id가 NULL입니다.';
        RAISE EXCEPTION '로그인이 필요합니다.';
    END IF;

    -- 게시판 설정에서 다운로드 포인트 조회 (게시판 ID가 제공된 경우)
    IF p_board_id IS NOT NULL THEN
        SELECT point_settings
        INTO v_board_settings
        FROM public.boards
        WHERE id = p_board_id;

        IF v_board_settings IS NULL THEN
            RAISE LOG '존재하지 않는 게시판입니다. board_id: %', p_board_id;
            RAISE EXCEPTION '존재하지 않는 게시판입니다.';
        END IF;

        IF v_board_settings IS NOT NULL THEN
            v_point_amount := COALESCE((v_board_settings ->> 'download_file')::INTEGER, 0);
        END IF;
    END IF;

    -- 포인트 차감 (포인트가 필요한 경우)
    IF v_point_amount > 0 THEN
        BEGIN
            PERFORM private.points_use(
                    v_user_id,
                    'ACTIVITY_POINT',
                    v_point_amount,
                    format('파일 다운로드: %s', p_file_path)
                    );
        EXCEPTION
            WHEN OTHERS THEN
                RAISE LOG '포인트 차감 오류: user_id=%, file_path=%, point_amount=%, error=%',
                    v_user_id, p_file_path, v_point_amount, SQLERRM;
                RAISE EXCEPTION '포인트 차감 중 오류가 발생했습니다. 포인트가 부족할 수 있습니다.';
        END;
    END IF;

    -- 다운로드 기록 생성/업데이트
    INSERT INTO public.file_download_histories (file_path,
                                                user_id,
                                                download_url,
                                                expires_at,
                                                point_amount)
    VALUES (p_file_path,
            v_user_id,
            p_download_url,
            p_expires_at,
            v_point_amount)
    ON CONFLICT (file_path, user_id)
        DO UPDATE SET download_url = EXCLUDED.download_url,
                      expires_at   = EXCLUDED.expires_at,
                      point_amount = EXCLUDED.point_amount,
                      created_at   = now();

    -- 성공 응답 반환
    RETURN jsonb_build_object(
            'success', TRUE,
            'download_url', p_download_url,
            'expires_at', p_expires_at,
            'point_deducted', v_point_amount,
            'message', CASE
                           WHEN v_point_amount > 0 THEN format('%s 포인트가 차감되었습니다.', v_point_amount)
                           ELSE '무료 다운로드입니다.'
                END
           );

EXCEPTION
    WHEN OTHERS THEN
        -- 에러 로깅
        RAISE LOG '파일 다운로드 기록 생성 오류: user_id=%, file_path=%, error=%',
            v_user_id, p_file_path, SQLERRM;

        RAISE EXCEPTION '파일 다운로드 생성 중 오류가 발생했습니다. %', SQLERRM;
END;
$$;

COMMENT ON FUNCTION public.file_download_history_create IS '파일 다운로드 기록 생성 및 포인트 차감 함수';

CREATE OR REPLACE FUNCTION public.post_download_history_create(
    p_post_id BIGINT,
    p_expires_at TIMESTAMPTZ
)
    RETURNS JSONB
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public, private
AS
$$
DECLARE
    v_user_id      BIGINT  := get_user_id_from_auth_uid();
    v_point_amount INTEGER := 0;
    v_post_data    RECORD;
BEGIN
    -- 로그인 확인
    IF v_user_id IS NULL THEN
        RAISE LOG '로그인이 필요합니다. user_id가 NULL입니다.';
        RAISE EXCEPTION '로그인이 필요합니다.';
    END IF;

    -- 게시물 존재 여부 및 게시판 정보 확인
    SELECT p.id,
           p.board_id,
           p.writer_id,
           p.status,
           p.attachments,
           p.deleted_at,
           p.download_point,
           b.point_settings
    INTO v_post_data
    FROM public.posts p
             JOIN public.boards b ON p.board_id = b.id
    WHERE p.id = p_post_id;

    IF v_post_data.id IS NULL THEN
        RAISE LOG '존재하지 않는 게시물입니다. post_id: %', p_post_id;
        RAISE EXCEPTION '존재하지 않는 게시물입니다.';
    END IF;

    -- 게시물 상태 확인
    IF v_post_data.status != 'published' OR v_post_data.deleted_at IS NOT NULL THEN
        RAISE LOG '다운로드할 수 없는 게시물입니다. post_id: %', p_post_id;
        RAISE EXCEPTION '다운로드할 수 없는 게시물입니다.';
    END IF;

    -- 본인 게시물인지 확인 (본인 게시물은 무료)
    IF v_post_data.writer_id = v_user_id THEN
        v_point_amount := 0;
    ELSE
        IF v_post_data.download_point > 0 THEN
            v_point_amount := v_post_data.download_point;
        ELSE
            -- 게시판 설정에서 다운로드 포인트 조회
            v_point_amount := COALESCE((v_post_data.point_settings ->> 'download_file')::INTEGER, 0);
        END IF;
    END IF;

    -- 포인트 차감 (포인트가 필요한 경우)
    IF v_point_amount > 0 THEN
        BEGIN
            PERFORM private.points_use(
                    v_user_id,
                    'ACTIVITY_POINT',
                    v_point_amount,
                    format('게시물 다운로드: 게시물 #%s', p_post_id)
                    );
        EXCEPTION
            WHEN OTHERS THEN
                RAISE LOG '포인트 차감 오류: user_id=%, post_id=%, point_amount=%, error=%',
                    v_user_id, p_post_id, v_point_amount, SQLERRM;
                RAISE EXCEPTION '포인트 차감 중 오류가 발생했습니다. (포인트 부족 또는 기타 오류)';
        END;
    END IF;

    -- 다운로드 기록 생성/업데이트
    INSERT INTO public.post_download_histories (post_id,
                                                user_id,
                                                point_amount,
                                                expires_at)
    VALUES (p_post_id,
            v_user_id,
            v_point_amount,
            p_expires_at)
    ON CONFLICT (post_id, user_id)
        DO UPDATE SET point_amount = EXCLUDED.point_amount,
                      expires_at   = EXCLUDED.expires_at,
                      created_at   = now();

    -- 챌린지 진행도 업데이트 (포인트가 차감된 경우에만)
    IF v_point_amount > 0 THEN
        BEGIN
            PERFORM private.user_challenge_progress_increment(
                p_user_id := v_user_id,
                p_action_code := 'download',
                p_board_id := v_post_data.board_id
            );
        EXCEPTION WHEN OTHERS THEN
            -- 챌린지 업데이트 실패해도 다운로드는 성공으로 처리
            RAISE WARNING '챌린지 진행도 업데이트 실패: %', SQLERRM;
        END;
    END IF;

    -- 성공 응답 반환
    RETURN jsonb_build_object(
            'success', TRUE,
            'download_urls', v_post_data.attachments,
            'expires_at', p_expires_at,
            'point_deducted', v_point_amount,
            'message', CASE
                           WHEN v_point_amount > 0 THEN format('%s 포인트가 차감되었습니다.', v_point_amount)
                           ELSE '무료 다운로드입니다.'
                END
           );

EXCEPTION
    WHEN OTHERS THEN
        -- 에러 로깅
        RAISE LOG '게시물 다운로드 기록 생성 오류: user_id=%, post_id=%, error=%',
            v_user_id, p_post_id, SQLERRM;

        RAISE EXCEPTION '첨부파일 다운로드 중 오류가 발생했습니다. %', SQLERRM;
END;
$$;

COMMENT ON FUNCTION public.post_download_history_create IS '게시물 다운로드 기록 생성 및 포인트 차감 함수';

-- File: docker/volumes/db/init/functions/08-reactions/01-point-process.sql
CREATE OR REPLACE FUNCTION reactions_point_process()
    RETURNS TRIGGER
    SET search_path = public
AS
$$
DECLARE
    v_point_amount   numeric;
    v_policy_id      bigint = 1; -- 활동 포인트 정책 ID
    v_board_settings jsonb;
    v_board_id       bigint;
    v_target_user_id bigint;
    v_point_setting_key text;
BEGIN
    -- target_type에 따른 처리
    CASE NEW.target_type
        WHEN 'post' THEN
            -- 게시글 작성자 ID와 게시판 ID 조회
            SELECT created_by, board_id
            INTO v_target_user_id, v_board_id
            FROM posts
            WHERE id = NEW.target_id;

            -- 포인트 설정 키 결정
            v_point_setting_key := CASE
                                       WHEN NEW.reaction_type = 'like' THEN 'like_post'
                                       ELSE 'dislike_post'
                END;

        WHEN 'comment' THEN
            -- 댓글 작성자 ID 조회 및 해당 게시글의 게시판 ID 조회
            WITH comment_info AS (
                SELECT c.writer_id, p.board_id
                FROM comments c
                         JOIN posts p ON c.post_id = p.id
                WHERE c.id = NEW.target_id
            )
            SELECT writer_id, board_id
            INTO v_target_user_id, v_board_id
            FROM comment_info;

            -- 포인트 설정 키 결정
            v_point_setting_key := CASE
                                       WHEN NEW.reaction_type = 'like' THEN 'like_comment'
                                       ELSE 'dislike_comment'
                END;

        ELSE
            -- post나 comment가 아닌 경우 처리하지 않음
            RETURN NEW;
        END CASE;

    -- 자신의 게시글/댓글에 대한 추천/비추천은 포인트에 영향을 주지 않음
    IF NEW.user_id = v_target_user_id THEN
        RETURN NEW;
    END IF;

    -- 게시판 포인트 설정 조회
    SELECT point_settings
    INTO v_board_settings
    FROM boards
    WHERE id = v_board_id;

    -- 포인트 금액 추출
    v_point_amount := (v_board_settings ->> v_point_setting_key)::numeric;

    -- 포인트가 0보다 큰 경우에만 처리
    IF v_point_amount > 0 THEN
        IF NEW.reaction_type = 'like' THEN
            PERFORM private.points_issue(
                    v_target_user_id,
                    'ACTIVITY_POINT',
                    v_point_amount,
                    v_policy_id,
                    format('%s 추천 포인트 획득 (ID: %s)',
                           CASE NEW.target_type
                               WHEN 'post' THEN '게시글'
                               WHEN 'comment' THEN '댓글'
                               END,
                           NEW.target_id
                    )
                    );
        ELSE -- dislike
            PERFORM private.points_use(
                    v_target_user_id,
                    'ACTIVITY_POINT',
                    v_point_amount,
                    format('%s 비추천으로 인한 포인트 차감 (ID: %s)',
                           CASE NEW.target_type
                               WHEN 'post' THEN '게시글'
                               WHEN 'comment' THEN '댓글'
                               END,
                           NEW.target_id
                    )
                    );
        END IF;
    END IF;

    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- 에러 로깅
        INSERT INTO point_error_logs (
            error_type,
            error_message,
            user_id,
            point_code,
            amount,
            table_name,
            table_record_id,
            additional_info
        )
        VALUES (
                   CASE
                       WHEN NEW.reaction_type = 'like' THEN
                           'ISSUE'
                       ELSE
                           'USE'
                       END,
                   SQLERRM,
                   v_target_user_id,
                   'ACTIVITY_POINT',
                   v_point_amount,
                   'reactions',
                   NEW.target_id,
                   jsonb_build_object(
                           'source', 'reactions_point_process',
                           'reaction_type', NEW.reaction_type,
                           'target_type', NEW.target_type,
                           'board_id', v_board_id,
                           'error_detail', SQLSTATE
                   )
               );
        RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- File: docker/volumes/db/init/functions/08-reactions/02-current-user-has-reactions.sql
CREATE OR REPLACE FUNCTION reactions_post_by_current_user(posts) RETURNS text
    STABLE
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS
$$
DECLARE
    v_user_id INTEGER := get_user_id_from_auth_uid();
    v_reaction_type TEXT;
BEGIN
    SELECT reaction_type
    FROM reactions
    WHERE target_type = 'post'::reaction_target_type
      AND target_id = $1.id
      AND user_id = v_user_id
    INTO v_reaction_type;

    RETURN v_reaction_type;
END;
$$;

CREATE OR REPLACE FUNCTION reactions_comment_by_current_user(comments) RETURNS text
    STABLE
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS
$$
DECLARE
    v_user_id INTEGER := get_user_id_from_auth_uid();
    v_reaction_type TEXT;
BEGIN
    SELECT reaction_type
    FROM reactions
    WHERE target_type = 'comment'::reaction_target_type
      AND target_id = $1.id
      AND user_id = v_user_id
    INTO v_reaction_type;

    RETURN v_reaction_type;
END;
$$;



-- File: docker/volumes/db/init/functions/08-reactions/03-create.sql
CREATE OR REPLACE FUNCTION public.reactions_create(
    p_target_type TEXT,
    p_target_id BIGINT,
    p_reaction_type TEXT
) RETURNS BOOLEAN
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public, private
AS $$
DECLARE
    v_user_id BIGINT := get_user_id_from_auth_uid();
    v_existing_reaction_type TEXT;
    v_board_id BIGINT;
    v_current_time TIMESTAMPTZ := now();
    v_target_type_enum public.reaction_target_type;
    v_reaction_type_enum public.reaction_type;
BEGIN
    -- 입력 검증
    IF p_target_id IS NULL THEN
        RAISE EXCEPTION '대상 ID가 필요합니다.';
    END IF;

    IF p_target_type IS NULL OR p_target_type NOT IN ('post', 'comment', 'user') THEN
        RAISE EXCEPTION '대상 타입은 post, comment, user만 가능합니다.';
    END IF;

    IF p_reaction_type IS NULL OR p_reaction_type NOT IN ('like', 'dislike') THEN
        RAISE EXCEPTION '리액션 타입은 like 또는 dislike만 가능합니다.';
    END IF;

    -- TEXT를 ENUM으로 캐스팅
    v_target_type_enum := p_target_type::public.reaction_target_type;
    v_reaction_type_enum := p_reaction_type::public.reaction_type;

    -- 로그인 확인
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION '로그인이 필요합니다.';
    END IF;

    -- 대상 존재 확인 및 게시판 ID 조회 (게시물/댓글의 경우)
    IF v_target_type_enum = 'post' THEN
        SELECT p.board_id INTO v_board_id
        FROM public.posts p
        WHERE p.id = p_target_id AND p.deleted_at IS NULL;

        IF NOT FOUND THEN
            RAISE EXCEPTION '존재하지 않는 게시글입니다.';
        END IF;
    ELSIF v_target_type_enum = 'comment' THEN
        SELECT p.board_id INTO v_board_id
        FROM public.comments c
        JOIN public.posts p ON c.post_id = p.id
        WHERE c.id = p_target_id AND c.deleted_at IS NULL AND p.deleted_at IS NULL;

        IF NOT FOUND THEN
            RAISE EXCEPTION '존재하지 않는 댓글입니다.';
        END IF;
    ELSIF v_target_type_enum = 'user' THEN
        IF NOT EXISTS (SELECT 1 FROM public.users WHERE id = p_target_id) THEN
            RAISE EXCEPTION '존재하지 않는 사용자입니다.';
        END IF;
        v_board_id := NULL; -- 사용자 리액션은 게시판과 무관
    END IF;

    -- 기존 리액션 확인
    SELECT reaction_type INTO v_existing_reaction_type
    FROM public.reactions
    WHERE target_type = v_target_type_enum
      AND target_id = p_target_id
      AND user_id = v_user_id;

    -- 기존 리액션이 있으면 에러 (취소 불가)
    IF v_existing_reaction_type IS NOT NULL THEN
        RAISE EXCEPTION '이미 리액션을 표시했습니다. (현재: %)', v_existing_reaction_type;
    END IF;

    -- TODO: 추후 취소 기능이 추가될 경우 아래 주석을 해제하고 위의 에러 처리를 제거
    -- IF v_existing_reaction_type IS NOT NULL THEN
    --     -- 기존 리액션과 같은 타입이면 삭제 (토글)
    --     IF v_existing_reaction_type = p_reaction_type THEN
    --         DELETE FROM public.reactions
    --         WHERE target_type = v_target_type_enum
    --           AND target_id = p_target_id
    --           AND user_id = v_user_id;
    --         RETURN FALSE; -- 리액션 취소됨
    --     ELSE
    --         -- 다른 리액션이면 업데이트
    --         UPDATE public.reactions
    --         SET reaction_type = p_reaction_type,
    --             created_at = v_current_time
    --         WHERE target_type = v_target_type_enum
    --           AND target_id = p_target_id
    --           AND user_id = v_user_id;
    --         RETURN TRUE; -- 리액션 변경됨
    --     END IF;
    -- ELSE

    -- 새 리액션 생성
    INSERT INTO public.reactions (
        target_type,
        target_id,
        user_id,
        reaction_type,
        created_at
    ) VALUES (
        v_target_type_enum,
        p_target_id,
        v_user_id,
        v_reaction_type_enum,
        v_current_time
    );

    -- 챌린지 진행도 업데이트 (게시물/댓글 리액션만)
    IF v_board_id IS NOT NULL THEN
        BEGIN
            PERFORM private.user_challenge_progress_increment(
                p_user_id := v_user_id,
                p_action_code := 'reaction',
                p_board_id := v_board_id
            );
        EXCEPTION WHEN OTHERS THEN
            -- 챌린지 업데이트 실패해도 리액션 생성은 성공으로 처리
            RAISE WARNING '챌린지 진행도 업데이트 실패: %', SQLERRM;
        END;
    END IF;

    RETURN TRUE; -- 리액션 생성됨

    -- END IF; -- TODO: 취소 기능 추가 시 주석 해제

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '리액션 처리 실패: %', SQLERRM;
END;
$$;

COMMENT ON FUNCTION public.reactions_create(TEXT, BIGINT, TEXT) IS '리액션 생성 함수 (게시물/댓글/사용자 지원, 취소 불가, 중복 생성 방지)';

-- File: docker/volumes/db/init/functions/11-faqs/01-faq-increment-view-count.sql
-- FAQ 조회수 증가 함수
CREATE OR REPLACE FUNCTION faq_increment_view_count(faq_id bigint)
    RETURNS void AS
$$
BEGIN
    UPDATE faqs
    SET view_count = view_count + 1
    WHERE id = faq_id;
END;
$$ LANGUAGE plpgsql;

-- File: docker/volumes/db/init/functions/14-points/01-use.sql
CREATE OR REPLACE FUNCTION private.points_use(p_user_id bigint, p_point_code text, p_amount numeric, p_description text) RETURNS void
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
AS
$$
DECLARE
    v_remaining       NUMERIC := p_amount;
    v_transaction     RECORD;
    v_use_amount      NUMERIC;
    v_current_balance NUMERIC;
    v_balance_after   NUMERIC;
BEGIN
    IF p_amount IS NOT NULL AND  p_amount <= 0 THEN
        RAISE EXCEPTION '포인트 사용량은 0보다 커야 합니다. 요청된 amount: [ % ]', p_amount;
    END IF;

    -- 현재 잔액 조회 (FOR UPDATE로 락 획득)
    SELECT balance
    INTO v_current_balance
    FROM user_point_wallets
    WHERE user_id = p_user_id
      AND point_code = p_point_code
        FOR UPDATE;

    -- 사용 가능한 포인트 잔액 확인
    IF v_current_balance < p_amount THEN
        RAISE EXCEPTION '포인트 잔액 부족: 현재 잔액 [ % ] 은 요청된 amount [ % ] 보다 적습니다.', v_current_balance, p_amount;
    END IF;

    v_balance_after := v_current_balance;

    -- FIFO 방식으로 포인트 사용
    FOR v_transaction IN (SELECT pt.id,
                                 pt.amount - COALESCE(
                                         (SELECT SUM(ABS(amount))
                                          FROM point_transactions pt2
                                          WHERE pt2.transaction_type = 'USE'
                                            AND pt2.related_transaction_id = pt.id),
                                         0
                                             ) AS available_amount,
                                 pt.expiration_date
                          FROM point_transactions pt
                          WHERE pt.user_id = p_user_id
                            AND pt.point_code = p_point_code
                            AND pt.transaction_type = 'EARN'
                            AND (pt.expiration_date IS NULL OR pt.expiration_date > CURRENT_DATE)
                          ORDER BY pt.created_at
                              FOR UPDATE)
        LOOP
            EXIT WHEN v_remaining <= 0;

            -- 만료된 포인트는 건너뛰기
            IF v_transaction.expiration_date IS NOT NULL AND v_transaction.expiration_date <= CURRENT_DATE THEN
                CONTINUE;
            END IF;

            -- available_amount가 0 이하인 경우 건너뛰기
            IF v_transaction.available_amount <= 0 THEN
                CONTINUE;
            END IF;

            v_use_amount := LEAST(v_transaction.available_amount, v_remaining);
            v_balance_after := v_balance_after - v_use_amount;

            -- 포인트 사용 트랜잭션 기록
            INSERT INTO point_transactions (user_id,
                                            point_code,
                                            description,
                                            amount,
                                            balance_after,
                                            transaction_type,
                                            related_transaction_id,
                                            expiration_date)
            VALUES (p_user_id,
                    p_point_code,
                    p_description,
                    -v_use_amount,
                    v_balance_after,
                    'USE',
                    v_transaction.id,
                    v_transaction.expiration_date);

            v_remaining := v_remaining - v_use_amount;
        END LOOP;

    -- 잔액 업데이트
    UPDATE user_point_wallets
    SET balance = v_balance_after
    WHERE user_id = p_user_id
      AND point_code = p_point_code;

    IF v_remaining > 0 THEN
        RAISE LOG '포인트 사용 요청량 [ % ] 중 [ % ] 은 사용되지 않았습니다. 사용자의 지갑과 point_transactions 정보를 확인해야합니다.', p_amount, v_remaining;
        RAISE EXCEPTION '포인트 사용에 문제가 발생했습니다. 고객센터로 문의하세요.';
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        -- 에러 로그 삽입
        INSERT INTO point_error_logs (error_type, error_message, user_id, point_code, amount, table_name, table_record_id, additional_info)
        VALUES ('USE', SQLERRM, p_user_id, p_point_code, p_amount, 'user_point_wallets', null,
                jsonb_build_object(
                        'source', 'points_use',
                        'action', 'point_use',
                        'current_balance', v_current_balance,
                        'requested_amount', p_amount,
                        'original_description', p_description,
                ));

        RAISE;
END;
$$;


-- File: docker/volumes/db/init/functions/14-points/02-issue.sql
CREATE OR REPLACE FUNCTION private.points_issue(p_user_id bigint, p_point_code text, p_amount numeric, p_policy_id bigint, p_description text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
AS
$$
DECLARE
    v_current_balance NUMERIC;
    v_expiration_date timestamptz;
    v_policy          RECORD;
    v_wallet_version  INTEGER;
    v_current_date    DATE := CURRENT_DATE;
BEGIN
    -- 정책 정보 조회 및 검증
    SELECT *
    INTO v_policy
    FROM point_policies
    WHERE id = p_policy_id;

    IF NOT FOUND THEN
        RAISE LOG '포인트 정책 ID(id=%)를 찾을 수 없습니다.', p_policy_id;
        RAISE EXCEPTION '유효하지 않은 포인트 발급 정책 입니다.';
    END IF;

    IF v_policy.point_code != p_point_code THEN
        RAISE LOG '정책(id=%)의 포인트 코드가 요청된 포인트 코드(point_code=%)와 일치하지 않습니다.', p_policy_id, p_point_code;
        RAISE EXCEPTION '유효하지 않은 포인트 코드 정책 입니다.';
    END IF;

    -- 만료일 계산 (UTC 기준)
    v_expiration_date := CASE
                             WHEN v_policy.expiration_period_type = 'NEVER' THEN NULL
                             WHEN v_policy.expiration_period_type = 'DATE' THEN v_policy.fixed_expiration_date
                             WHEN v_policy.expiration_period_type = 'DAY' THEN now() + (v_policy.expiration_period || ' DAYS')::INTERVAL
                             WHEN v_policy.expiration_period_type = 'MONTH' THEN now() + (v_policy.expiration_period || ' MONTHS')::INTERVAL
                             WHEN v_policy.expiration_period_type = 'YEAR' THEN now() + (v_policy.expiration_period || ' YEARS')::INTERVAL
                             WHEN v_policy.expiration_period_type = 'WEEK' THEN v_current_date + ((8 - EXTRACT(DOW FROM v_current_date))::INTEGER % 7 + 7) * INTERVAL '1 DAY'
        END;

    -- 현재 잔액 조회 및 업데이트 (낙관적 락킹 사용)
    SELECT balance, version
    INTO v_current_balance, v_wallet_version
    FROM user_point_wallets
    WHERE user_id = p_user_id
      AND point_code = p_point_code
        FOR UPDATE;

    IF NOT FOUND THEN
        INSERT INTO user_point_wallets (user_id, point_code, balance, version)
        VALUES (p_user_id, p_point_code, p_amount, 1)
        RETURNING balance, version INTO v_current_balance, v_wallet_version;
    ELSE
        UPDATE user_point_wallets
        SET balance = balance + p_amount,
            version = version + 1
        WHERE user_id = p_user_id
          AND point_code = p_point_code
          AND version = v_wallet_version
        RETURNING balance, version INTO v_current_balance, v_wallet_version;

        IF NOT FOUND THEN
            -- 업데이트 실패 시, 다른 트랜잭션이 먼저 업데이트한 경우
            RAISE LOG '포인트 지갑(user_id=%, point_code=%)의 버전(version=%)이 일치하지 않습니다.', p_user_id, p_point_code, v_wallet_version;
            RAISE EXCEPTION '포인트 사용에 문제가 발생했습니다. 다시 시도해 주세요.';
        END IF;
    END IF;

    -- 포인트 발행 트랜잭션 기록
    INSERT INTO point_transactions (user_id,
                                    point_code,
                                    amount,
                                    balance_after,
                                    transaction_type,
                                    policy_id,
                                    expiration_date,
                                    description)
    VALUES (p_user_id,
            p_point_code,
            p_amount,
            v_current_balance,
            'EARN',
            p_policy_id,
            v_expiration_date,
            p_description);

EXCEPTION
    WHEN OTHERS THEN
        -- 에러 로그 삽입
        INSERT INTO point_error_logs (error_type, error_message, user_id, point_code, amount, table_name, table_record_id, additional_info)
        VALUES ('ISSUE', SQLERRM, p_user_id, p_point_code, p_amount, 'user_point_wallets', null, '{
          "source": "points_issue",
          "action": "point_issue"
        }'::JSONB);

        -- 예외를 다시 발생시켜 호출자에게 오류를 알림
        RAISE;
END;
$$;


-- File: docker/volumes/db/init/functions/14-points/03-expire.sql
CREATE FUNCTION private.points_expire() RETURNS void
    LANGUAGE plpgsql
    SET search_path = public
AS
$$
DECLARE
    v_expired_transaction RECORD;
    v_current_balance     NUMERIC;
    v_expired_amount      NUMERIC;
    v_balance_after       NUMERIC;
    v_total_expired       NUMERIC := 0;
    v_start_time          TIMESTAMP;
    v_end_time            TIMESTAMP;
    v_current_date        DATE;
BEGIN
    RAISE LOG 'Point expiration started.';

    -- 현재 한국 시간 기준의 날짜를 계산
    v_current_date := (now() AT TIME ZONE 'Asia/Seoul')::DATE;
    RAISE LOG 'Point expiration date: %', v_current_date;

    v_start_time := clock_timestamp();

    -- 만료된 포인트 트랜잭션 조회 및 처리
    FOR v_expired_transaction IN (SELECT pt.id,
                                         pt.user_id,
                                         pt.point_code,
                                         pt.amount,
                                         pt.amount + COALESCE(
                                                 (SELECT SUM(amount)
                                                  FROM point_transactions pt2
                                                  WHERE pt2.transaction_type = 'USE'
                                                    AND pt2.related_transaction_id = pt.id), 0) AS expired_amount
                                  FROM point_transactions pt
                                  WHERE pt.transaction_type = 'EARN'
                                    AND pt.expiration_date = v_current_date
                                    AND pt.amount + COALESCE(
                                          (SELECT SUM(amount)
                                           FROM point_transactions pt2
                                           WHERE pt2.transaction_type = 'USE'
                                             AND pt2.related_transaction_id = pt.id), 0) > 0)
        LOOP
            -- 현재 잔액 조회
            SELECT balance
            INTO v_current_balance
            FROM user_point_wallets
            WHERE user_id = v_expired_transaction.user_id
              AND point_code = v_expired_transaction.point_code
                FOR UPDATE;

            v_expired_amount := LEAST(v_expired_transaction.expired_amount, v_current_balance);
            v_balance_after := v_current_balance - v_expired_amount;

            -- 만료 트랜잭션 기록
            INSERT INTO point_transactions (user_id, point_code, amount, balance_after,
                                            transaction_type, related_transaction_id, description)
            VALUES (v_expired_transaction.user_id,
                    v_expired_transaction.point_code,
                    -v_expired_amount,
                    v_balance_after,
                    'EXPIRE',
                    v_expired_transaction.id,
                    '포인트 만료');

            -- 잔액 업데이트
            UPDATE user_point_wallets
            SET balance = v_balance_after
            WHERE user_id = v_expired_transaction.user_id
              AND point_code = v_expired_transaction.point_code;

            v_total_expired := v_total_expired + v_expired_amount;
        END LOOP;

    v_end_time := clock_timestamp();

    -- 로그 기록
    INSERT INTO point_expiration_logs (execution_date, total_expired_amount, execution_time)
    VALUES (v_current_date, v_total_expired, v_end_time - v_start_time);

    RAISE LOG 'Point expiration completed. Total expired: %, Execution time: %', v_total_expired, v_end_time - v_start_time;
EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG 'Point expiration failed. Error: %', SQLERRM;
END;
$$;


-- File: docker/volumes/db/init/functions/14-points/05-issue-by-failed.sql
CREATE OR REPLACE FUNCTION private.reprocess_failed_point_issues()
    RETURNS TABLE(processed_count INTEGER, success_count INTEGER, error_count INTEGER)
    LANGUAGE plpgsql
    SET search_path = public
AS $$
DECLARE
    v_error_log RECORD;
    v_processed_count INTEGER := 0;
    v_success_count INTEGER := 0;
    v_error_count INTEGER := 0;
BEGIN
    RAISE NOTICE '포인트 재지급 프로세스 시작...';

    -- 재지급 대상 로그들을 순차 처리
    FOR v_error_log IN
        SELECT id, user_id, amount, error_message, additional_info
        FROM public.point_error_logs
        WHERE error_type = 'ISSUE'
          AND created_at >= NOW() - INTERVAL '7 days'
          -- additional_info.reprocessed 필드 체크로 중복 방지
          AND (additional_info IS NULL
            OR additional_info->>'reprocessed' IS NULL
            OR additional_info->>'reprocessed' != 'true')
        ORDER BY created_at
        LOOP
            BEGIN
                v_processed_count := v_processed_count + 1;

                -- 개별적으로 포인트 지급 시도
                PERFORM private.points_issue(
                        v_error_log.user_id,
                        'ACTIVITY_POINT',
                        v_error_log.amount,
                        1,
                        concat('포인트 지급 실패 재지급 (에러로그 ID: ', v_error_log.id, ')')
                        );

                v_success_count := v_success_count + 1;

                -- 성공한 경우 reprocessed 플래그 설정
                UPDATE public.point_error_logs
                SET additional_info = COALESCE(additional_info, '{}'::jsonb) ||
                                      jsonb_build_object(
                                              'reprocessed', true,
                                              'reprocessed_at', NOW(),
                                              'reprocessed_by', 'reprocess_failed_point_issues'
                                      )
                WHERE id = v_error_log.id;

                RAISE NOTICE '재지급 성공: error_log_id=%, user_id=%, amount=%',
                    v_error_log.id, v_error_log.user_id, v_error_log.amount;

            EXCEPTION
                WHEN OTHERS THEN
                    v_error_count := v_error_count + 1;

                    RAISE LOG '포인트 재지급 실패: error_log_id=%, user_id=%, amount=%, error=%',
                        v_error_log.id, v_error_log.user_id, v_error_log.amount, SQLERRM;

                    -- 실패한 경우에도 시도했다는 기록 남기기
                    UPDATE public.point_error_logs
                    SET additional_info = COALESCE(additional_info, '{}'::jsonb) ||
                                          jsonb_build_object(
                                                  'reprocess_attempted', true,
                                                  'reprocess_attempted_at', NOW(),
                                                  'reprocess_error', SQLERRM
                                          )
                    WHERE id = v_error_log.id;
            END;
        END LOOP;

    RAISE NOTICE '포인트 재지급 완료: 처리대상=%, 성공=%, 실패=%',
        v_processed_count, v_success_count, v_error_count;

    RETURN QUERY SELECT v_processed_count, v_success_count, v_error_count;
END;
$$;

-- File: docker/volumes/db/init/functions/16-banners/01-click-count.sql
-- 배너 클릭 이벤트 트래킹을 위한 함수
CREATE OR REPLACE FUNCTION banners_increment_click_count(p_banner_id bigint)
    RETURNS void AS
$$
BEGIN
    UPDATE banners
    SET click_count = click_count + 1
    WHERE id = p_banner_id;
END;
$$ LANGUAGE plpgsql;

-- File: docker/volumes/db/init/functions/18-coins/01-create-point-purchase.sql
CREATE OR REPLACE FUNCTION coin_point_purchase_requests_create(
    p_coin_code TEXT,
    p_payment_method TEXT,
    p_deposit_amount INTEGER,
    p_wallet_address TEXT,
    p_transaction_id TEXT,
    p_exchange_name TEXT DEFAULT NULL,
    p_coin_name_custom TEXT DEFAULT NULL)
    RETURNS JSONB
    SECURITY DEFINER
    LANGUAGE plpgsql
AS
$$
DECLARE
    v_user_id    BIGINT := get_user_id_from_auth_uid();
    v_request_id BIGINT;
    v_point_code TEXT   := 'ACTIVITY_POINT';
BEGIN
    IF v_user_id IS NULL THEN
        RAISE LOG 'coin_point_purchase_requests_create: 로그인된 사용자가 없습니다.';
        RAISE EXCEPTION '로그인이 필요합니다.';
    END IF;

    -- 입력값 검증
    IF p_deposit_amount <= 0 THEN
        RAISE EXCEPTION '입금 금액은 0보다 커야 합니다.';
    END IF;

    IF LENGTH(p_wallet_address) < 10 THEN
        RAISE EXCEPTION '지갑 주소는 최소 10자 이상이어야 합니다.';
    END IF;

    IF LENGTH(p_transaction_id) < 5 THEN
        RAISE EXCEPTION '트랜잭션 ID는 최소 5자 이상이어야 합니다.';
    END IF;

    -- 코인 타입 존재 및 구매 가능 여부 확인
    IF NOT EXISTS (SELECT 1
                   FROM public.coin_types
                   WHERE coin_code = p_coin_code
                     AND is_active = true
                     AND is_purchase_enabled = true) THEN
        RAISE EXCEPTION '선택한 코인은 구매할 수 없습니다.';
    END IF;

    -- 기타 코인인 경우 커스텀 이름 필수
    IF p_coin_code = 'other' AND (p_coin_name_custom IS NULL OR LENGTH(p_coin_name_custom) = 0) THEN
        RAISE EXCEPTION '기타 코인을 선택한 경우 코인명을 입력해야 합니다.';
    END IF;

    -- 구매 요청 생성
    INSERT INTO public.coin_point_purchase_requests (user_id,
                                                     coin_code,
                                                     coin_name_custom,
                                                     exchange_name,
                                                     payment_method,
                                                     deposit_amount,
                                                     wallet_address,
                                                     transaction_id,
                                                     point_code)
    VALUES (v_user_id,
            p_coin_code,
            p_coin_name_custom,
            p_exchange_name,
            p_payment_method,
            p_deposit_amount,
            p_wallet_address,
            p_transaction_id,
            v_point_code)
    RETURNING id INTO v_request_id;

    RETURN jsonb_build_object(
            'success', true,
            'request_id', v_request_id,
            'message', '포인트 구매 요청이 성공적으로 생성되었습니다.'
           );

EXCEPTION
    WHEN unique_violation THEN
        RAISE EXCEPTION '이미 동일한 트랜잭션으로 요청된 내역이 있습니다.';
    WHEN OTHERS THEN
        RAISE LOG '포인트 구매 요청 생성 오류: user_id=%, error=%', v_user_id, SQLERRM;
        RAISE EXCEPTION '포인트 구매 요청 생성 중 오류가 발생했습니다.';
END;
$$;

COMMENT ON FUNCTION public.coin_point_purchase_requests_create IS '코인 포인트 구매 요청 생성 함수';

-- File: docker/volumes/db/init/functions/18-coins/02-cancel-point-purchase.sql
CREATE OR REPLACE FUNCTION public.coin_purchase_request_cancel(
    p_request_id BIGINT
) RETURNS JSONB
    SECURITY DEFINER
    LANGUAGE plpgsql
AS $$
DECLARE
    v_user_id BIGINT := get_user_id_from_auth_uid();
    v_request RECORD;
BEGIN
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION '로그인이 필요합니다.';
    END IF;

    SELECT * INTO v_request
    FROM public.coin_point_purchase_requests
    WHERE id = p_request_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION '존재하지 않는 요청입니다.';
    END IF;

    IF v_request.user_id != v_user_id THEN
        RAISE EXCEPTION '본인의 요청만 취소할 수 있습니다.';
    END IF;

    IF v_request.status != 'requested' THEN
        RAISE EXCEPTION '포인트 구매 요청을 취소할 수 없습니다.';
    END IF;

    UPDATE public.coin_point_purchase_requests
    SET
        status = 'cancelled',
        updated_at = now()
    WHERE id = p_request_id;

    RETURN jsonb_build_object(
            'success', true,
            'request_id', p_request_id,
            'message', '포인트 구매 요청이 취소되었습니다.'
           );

EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG '포인트 구매 요청 취소 오류: request_id=%, user_id=%, error=%', p_request_id, v_user_id, SQLERRM;
        RAISE EXCEPTION '포인트 구매 요청 취소 중 오류가 발생했습니다.';
END;
$$;
COMMENT ON FUNCTION public.coin_purchase_request_cancel IS '사용자 구매 요청 취소 함수';

-- File: docker/volumes/db/init/functions/18-coins/03-process-point-purchase.sql
CREATE OR REPLACE FUNCTION public.coin_purchase_request_admin_process(
    p_request_id BIGINT,
    p_action TEXT, -- 'approve' or 'reject'
    p_issued_point_amount INTEGER DEFAULT NULL,
    p_rejection_reason TEXT DEFAULT NULL,
    p_admin_notes TEXT DEFAULT NULL
) RETURNS JSONB
    LANGUAGE plpgsql
AS
$$
DECLARE
    v_admin_id   BIGINT := get_user_id_from_auth_uid();
    v_request    RECORD;
    v_new_status TEXT;
BEGIN
    IF NOT is_admin() THEN
        RAISE EXCEPTION '관리자 권한이 필요합니다.';
    END IF;

    IF p_action NOT IN ('approve', 'reject') THEN
        RAISE EXCEPTION '잘못된 액션입니다. approve 또는 reject만 가능합니다.';
    END IF;

    SELECT *
    INTO v_request
    FROM public.coin_point_purchase_requests
    WHERE id = p_request_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION '존재하지 않는 요청입니다.';
    END IF;

    IF v_request.status != 'requested' THEN
        RAISE EXCEPTION '요청 상태의 건만 처리할 수 있습니다. 현재 상태: %', v_request.status;
    END IF;

    IF p_action = 'approve' THEN
        IF p_issued_point_amount IS NULL OR p_issued_point_amount <= 0 THEN
            RAISE EXCEPTION '승인 시 지급 포인트 금액을 입력해야 합니다.';
        END IF;
        v_new_status := 'approved';

        BEGIN
            PERFORM private.points_issue(v_request.user_id, 'ACTIVITY_POINT', p_issued_point_amount, 1, '포인트 구매');

        EXCEPTION WHEN OTHERS THEN
            RAISE LOG '포인트 구매 승인: 포인트 지급 실패 (user_id: %, error: %)', v_request.user_id, SQLERRM;
            -- 에러 로깅
            INSERT INTO point_error_logs (error_type,
                                          error_message,
                                          user_id,
                                          point_code,
                                          amount,
                                          table_name,
                                          table_record_id,
                                          additional_info)
            VALUES ('ISSUE',
                    SQLERRM,
                    v_request.user_id,
                    'ACTIVITY_POINT',
                    p_issued_point_amount,
                    'coin_point_purchase_requests',
                    v_request.id,
                    jsonb_build_object(
                            'source', 'coin_point_purchase_requests_process'
                    ));
        END;

    ELSE -- reject
        v_new_status := 'rejected';
    END IF;

    UPDATE public.coin_point_purchase_requests
    SET status              = v_new_status,
        processed_by        = v_admin_id,
        processed_at        = now(),
        issued_point_amount = CASE WHEN p_action = 'approve' THEN p_issued_point_amount END,
        rejection_reason    = CASE WHEN p_action = 'reject' THEN p_rejection_reason END,
        admin_notes         = p_admin_notes,
        updated_at          = now()
    WHERE id = p_request_id;

    RETURN jsonb_build_object(
            'success', true,
            'request_id', p_request_id,
            'new_status', v_new_status,
            'message', CASE
                           WHEN p_action = 'approve' THEN '구매 요청이 승인되었습니다.'
                           ELSE '구매 요청이 거절되었습니다.'
                END
           );

EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG '구매 요청 처리 오류: request_id=%, admin_id=%, error=%', p_request_id, v_admin_id, SQLERRM;
        RAISE EXCEPTION '구매 요청 처리 중 오류가 발생했습니다. %', SQLERRM;
END;
$$;
COMMENT ON FUNCTION public.coin_purchase_request_admin_process IS '관리자 구매 요청 처리 함수';

-- File: docker/volumes/db/init/functions/19-challenges/01-user-challenge-progress-increment.sql
-- 챌린지 진행도 업데이트 함수 (RPC 미노출)
CREATE OR REPLACE FUNCTION private.user_challenge_progress_increment(
    p_user_id BIGINT,
    p_action_code TEXT,
    p_board_id BIGINT DEFAULT NULL
) RETURNS void
    SET search_path = public
AS
$$
DECLARE
    challenge_rec     RECORD;
    composite_rec     RECORD;
    v_today           DATE := (NOW() AT TIME ZONE 'Asia/Seoul')::DATE;
    v_completed_count INTEGER;
    v_required_count  INTEGER;
BEGIN
    -- 1. 일반 챌린지 진행상황 업데이트
    FOR challenge_rec IN
        SELECT c.*, ct.type_code
        FROM challenges c
                 JOIN challenge_types ct ON c.type_code = ct.type_code
        WHERE c.action_code = p_action_code
          AND c.is_active = true
          AND ct.is_active = true
        LOOP
            -- 게시판 조건 체크
            IF challenge_rec.include_boards IS NOT NULL
                AND NOT (p_board_id = ANY (challenge_rec.include_boards)) THEN
                CONTINUE;
            END IF;

            IF challenge_rec.exclude_boards IS NOT NULL
                AND p_board_id = ANY (challenge_rec.exclude_boards) THEN
                CONTINUE;
            END IF;

            -- 진행상황 업데이트
            INSERT INTO public.user_challenge_progress (user_id, challenge_id, current_count, progress_date, expires_at)
            VALUES (p_user_id, challenge_rec.id, 1,
                    CASE WHEN challenge_rec.type_code = 'daily' THEN v_today END,
                    CASE
                        WHEN challenge_rec.type_code = 'accum' AND challenge_rec.expire_days IS NOT NULL
                            THEN v_today + INTERVAL '1 day' * challenge_rec.expire_days
                        END)
            ON CONFLICT (user_id, challenge_id, progress_date)
                DO UPDATE SET current_count = user_challenge_progress.current_count + 1,
                              updated_at    = now()
            WHERE user_challenge_progress.current_count < challenge_rec.target_count
              AND (challenge_rec.type_code != 'daily' OR user_challenge_progress.progress_date = v_today);

            RAISE LOG 'Challenge progress updated: user_id=%, challenge_id=%, action_code=%',
                p_user_id, challenge_rec.id, p_action_code;
        END LOOP;

    -- 2. composite 챌린지 체크 및 생성
    IF p_action_code = 'composite' THEN
        -- composite 액션으로 직접 호출된 경우 모든 composite 챌린지 체크
        FOR composite_rec IN
            SELECT c.*, ct.type_code
            FROM challenges c
                     JOIN challenge_types ct ON c.type_code = ct.type_code
            WHERE c.action_code = 'composite'
              AND c.is_active = true
              AND ct.is_active = true
              AND c.depends_on IS NOT NULL
            LOOP
                -- 의존성 개수 계산
                SELECT array_length(composite_rec.depends_on, 1) INTO v_required_count;

                -- 완료된 의존 챌린지 개수 계산
                SELECT COUNT(*)
                INTO v_completed_count
                FROM unnest(composite_rec.depends_on) AS dep_code
                WHERE EXISTS (SELECT 1
                              FROM user_challenge_progress up
                                       JOIN challenges c ON up.challenge_id = c.id
                              WHERE up.user_id = p_user_id
                                AND c.code = dep_code
                                AND up.is_claimed = true
                                AND (composite_rec.type_code = 'accum' OR up.progress_date = v_today));

                RAISE LOG 'Composite challenge check: challenge_id=%, required=%, completed=%',
                    composite_rec.id, v_required_count, v_completed_count;

                -- 모든 의존성이 완료된 경우 composite 챌린지 생성
                IF v_completed_count = v_required_count THEN
                    INSERT INTO public.user_challenge_progress (user_id, challenge_id, current_count, progress_date, expires_at)
                    VALUES (p_user_id, composite_rec.id, composite_rec.target_count,
                            CASE WHEN composite_rec.type_code = 'daily' THEN v_today END,
                            CASE
                                WHEN composite_rec.type_code = 'accum' AND composite_rec.expire_days IS NOT NULL
                                    THEN v_today + INTERVAL '1 day' * composite_rec.expire_days
                                END)
                    ON CONFLICT (user_id, challenge_id, progress_date)
                        DO UPDATE SET current_count = composite_rec.target_count,
                                      updated_at    = now()
                    WHERE user_challenge_progress.current_count < composite_rec.target_count;

                    RAISE LOG 'Composite challenge created: user_id=%, challenge_id=%',
                        p_user_id, composite_rec.id;
                END IF;
            END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION private.user_challenge_progress_increment IS '챌린지 진행도 업데이트 함수';

-- File: docker/volumes/db/init/functions/19-challenges/02-user-challenge-progress-claim-reward.sql
CREATE OR REPLACE FUNCTION user_challenge_progress_claim_reward(
    p_challenge_id BIGINT
) RETURNS jsonb
    SET search_path = public, private
AS $$
DECLARE
    v_user_id BIGINT := get_user_id_from_auth_uid();
    challenge_rec RECORD;
    progress_rec RECORD;
    can_claim BOOLEAN := false;
    result jsonb;
    v_policy_id BIGINT;
    v_point_code TEXT := 'ACTIVITY_POINT';
BEGIN
    -- 챌린지 정보 조회
    SELECT c.*, ct.type_code INTO challenge_rec
    FROM challenges c
             JOIN challenge_types ct ON c.type_code = ct.type_code
    WHERE c.id = p_challenge_id;

    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'challenge_not_found');
    END IF;

    -- 진행상황 조회
    SELECT * INTO progress_rec FROM user_challenge_progress
    WHERE user_id = v_user_id
      AND challenge_id = p_challenge_id
      AND (challenge_rec.type_code = 'accum' OR progress_date = CURRENT_DATE);

    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'progress_not_found');
    END IF;

    -- 보상 수령 가능 여부 체크
    can_claim := progress_rec.current_count >= challenge_rec.target_count
        AND NOT progress_rec.is_claimed;

    -- 복합 챌린지 의존성 체크
    IF challenge_rec.depends_on IS NOT NULL THEN
        can_claim := can_claim AND NOT EXISTS (
            SELECT 1 FROM unnest(challenge_rec.depends_on) AS dep_code
            WHERE NOT EXISTS (
                SELECT 1 FROM user_challenge_progress up2
                                  JOIN challenges c2 ON up2.challenge_id = c2.id
                WHERE up2.user_id = v_user_id
                  AND c2.code = dep_code
                  AND up2.is_claimed = true
                  AND (challenge_rec.type_code = 'accum' OR up2.progress_date = CURRENT_DATE)
            )
        );
    END IF;

    IF NOT can_claim THEN
        RETURN jsonb_build_object('success', false, 'error', 'cannot_claim');
    END IF;

    -- 연관 챌린지 등록 AND 업데이트 (composite 챌린지 처리)
    IF challenge_rec.action_code != 'composite' THEN
        BEGIN
            PERFORM private.user_challenge_progress_increment(
                    p_user_id := v_user_id,
                    p_action_code := 'composite'
                );

            EXCEPTION WHEN OTHERS THEN
                RAISE LOG '챌린지 보상 수령: 연관 챌린지 갱신 실패 (user_id: %, challenge_id: %, error: %)',
                    v_user_id, p_challenge_id, SQLERRM;
                RAISE EXCEPTION '챌린지 보상 수령 실패: 연관 챌린지 갱신 실패';
        END;
    END IF;

    -- 트랜잭션으로 보상 지급
    BEGIN
        SELECT id INTO v_policy_id
        FROM point_policies
        WHERE point_code = v_point_code
        ORDER BY id DESC
        LIMIT 1;

        -- 포인트 지급
        PERFORM private.points_issue(
                v_user_id,
                challenge_rec.point_code,
                challenge_rec.reward_point,
                v_policy_id,
                challenge_rec.id::text
                );

        -- 수령 상태 업데이트
        UPDATE user_challenge_progress
        SET is_claimed = true,
            claimed_at = now(),
            updated_at = now()
        WHERE user_id = v_user_id
          AND challenge_id = p_challenge_id
          AND (challenge_rec.type_code = 'accum' OR progress_date = CURRENT_DATE);

        result := jsonb_build_object(
                'success', true,
                'reward_point', challenge_rec.reward_point,
                'point_code', challenge_rec.point_code
                  );

    EXCEPTION WHEN OTHERS THEN
        result := jsonb_build_object('success', false, 'error', SQLERRM);
    END;

    RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION user_challenge_progress_claim_reward IS '챌린지 보상 지급 함수';

-- File: docker/volumes/db/init/functions/90-others/01-audit-handlers.sql
-- 파일: 01-audit-handlers.sql
-- 설명: 생성 및 수정 감사 처리 함수
-- 의존성: functions/02-users/01-users-utility.sql (get_user_id_from_auth_uid 함수)

-- 생성 Audit 핸들러
CREATE OR REPLACE FUNCTION created_info_handler()
    RETURNS TRIGGER AS
$$
BEGIN
    NEW.created_at = now();

    BEGIN
        NEW.created_by = get_user_id_from_auth_uid();
    EXCEPTION
        WHEN undefined_column THEN
            NULL;
    END;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 갱신 Audit 핸들러
CREATE OR REPLACE FUNCTION updated_info_handler()
    RETURNS TRIGGER AS
$$
BEGIN
    NEW.updated_at = now();

    BEGIN
        NEW.updated_by = get_user_id_from_auth_uid();
    EXCEPTION
        WHEN undefined_column THEN
            NULL;
    END;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;



-- =======================================
-- TRIGGERS
-- =======================================

-- File: docker/volumes/db/init/triggers/00-others/01-storage-objects-triggers.sql


-- File: docker/volumes/db/init/triggers/01-users/01-users-triggers.sql
-- 설명: 사용자 관련 트리거 함수 및 트리거

-- Auth 사용자 삭제 처리 트리거 함수
CREATE OR REPLACE FUNCTION auth_user_delete_handler() RETURNS trigger
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS
$$
BEGIN
    UPDATE public.users
    SET deleted_at = now()
    WHERE users.auth_user_id = OLD.id;
    RETURN OLD;
END;
$$;

-- Auth 사용자 삭제 트리거
CREATE TRIGGER tr_100_db_auth_user_bd_delete
    BEFORE DELETE
    ON auth.users
    FOR EACH ROW
EXECUTE PROCEDURE public.auth_user_delete_handler();

-- Auth 사용자 생성 트리거 함수
CREATE OR REPLACE FUNCTION public.auth_user_create_handler()
    RETURNS TRIGGER
    SECURITY DEFINER
    SET search_path = public, auth
AS
$$
DECLARE
    invite_code_attempt TEXT;
    nickname_attempt    TEXT;
    existing_user_id    BIGINT;
    v_register_level    INTEGER;
BEGIN
    -- 이미 생성된 계정 확인
    SELECT id
    INTO existing_user_id
    FROM public.users
    WHERE auth_user_id = NEW.id;

    IF existing_user_id IS NOT NULL THEN
        RETURN NEW;
    END IF;

    -- 유니크한 초대 코드 및 닉네임 생성
    LOOP
        invite_code_attempt := public.generate_random_code(6);
        nickname_attempt := public.generate_random_code(15);
        EXIT WHEN NOT EXISTS (SELECT 1
                              FROM public.users
                              WHERE invite_code = invite_code_attempt
                                 OR nickname = nickname_attempt);
    END LOOP;

    RAISE LOG 'Generated invite_code: %, nickname: %', invite_code_attempt, nickname_attempt;

    -- 최초 생성시 포인트 지급
    SELECT value
    INTO v_register_level
    FROM public.site_config_kv
    WHERE key = 'user.register_level';

    -- public.users 테이블에 사용자 추가
    INSERT INTO public.users (auth_user_id,
                              login_id,
                              email,
                              nickname,
                              invite_code,
                              status,
                              activity_level)
    VALUES (NEW.id,
            NEW.raw_user_meta_data ->> 'login_id',
            NEW.email,
            COALESCE(NEW.raw_user_meta_data ->> 'nickname', nickname_attempt),
            invite_code_attempt,
            'active'::public.user_status,
            COALESCE(v_register_level, 1));

    -- add role to raw_user_meta_data
    UPDATE auth.users
    set raw_user_meta_data = raw_user_meta_data || jsonb_build_object('role', 'user')
    where id = NEW.id;

    RETURN NEW;

EXCEPTION
    WHEN unique_violation THEN
        RAISE EXCEPTION 'Unique constraint violation: %', SQLERRM;
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error in auth_user_create_handler: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- Auth 사용자 생성 트리거
CREATE TRIGGER tr_100_ai_auth_user_create
    AFTER INSERT
    ON auth.users
    FOR EACH ROW
EXECUTE FUNCTION auth_user_create_handler();

CREATE OR REPLACE FUNCTION public.users_creation_handler()
    RETURNS TRIGGER
    SECURITY DEFINER
    SET search_path = public
    LANGUAGE plpgsql
AS
$$
DECLARE
    v_register_point               NUMERIC;
BEGIN
    -- 포인트 지갑 생성
    INSERT INTO public.user_point_wallets (user_id, point_code, balance)
    SELECT NEW.id, pc.code, 0
    FROM public.point_codes pc;

    -- 초대 받은 경우 초대자에게 포인트 지급
    IF NEW.invited_by IS NOT NULL THEN
        -- points_issue(p_user_id bigint, p_point_code text, p_amount numeric, p_policy_id bigint, p_description text DEFAULT NULL::text)
        PERFORM private.points_issue(NEW.invited_by, 'ACTIVITY_POINT', 100, 1, '초대 포인트 지급');
    END IF;

    -- 최초 생성시 포인트 지급
    SELECT value
    INTO v_register_point
    FROM site_config_kv
    WHERE key = 'user.register_point';

    IF v_register_point IS NOT NULL THEN
        PERFORM private.points_issue(NEW.id, 'ACTIVITY_POINT', v_register_point, 1, '회원가입 포인트 지급');
    END IF;

    RETURN NEW;
END;
$$;

CREATE TRIGGER tr_110_ai_users_creation
    AFTER INSERT
    ON public.users
    FOR EACH ROW
EXECUTE FUNCTION users_creation_handler();

-- 권한 변경 로깅 트리거 함수
create or replace function permission_changes_log()
    returns trigger as
$$
begin
    if old.permission_type != new.permission_type then
        insert into public.permission_changes (user_id,
                                               old_type,
                                               new_type,
                                               changed_by)
        values (new.id,
                old.permission_type,
                new.permission_type,
                get_user_id_from_auth_uid());
    end if;
    return new;
end;
$$ language plpgsql security definer;

-- 권한 변경 로깅 트리거
create trigger tr_log_permission_change
    after update
    on public.users
    for each row
    when (old.permission_type is distinct from new.permission_type)
execute function permission_changes_log();

-- super_admin 권한 검증 트리거 함수
CREATE OR REPLACE FUNCTION validate_super_admin_permission()
    RETURNS TRIGGER AS $$
BEGIN
    -- INSERT 또는 UPDATE로 permission_type이 super_admin이 되는 경우
    IF NEW.permission_type = 'super_admin' THEN
        -- 이미 다른 super_admin이 존재하는지 확인
        IF EXISTS (
            SELECT 1 FROM public.users
            WHERE permission_type = 'super_admin'
              AND id != NEW.id  -- 자기 자신은 제외
        ) THEN
            RAISE EXCEPTION '최고 관리자 계정은 1개만 지정 가능합니다.';
        END IF;
    END IF;

    -- UPDATE에서 super_admin 권한을 변경하려는 경우
    IF TG_OP = 'UPDATE' THEN
        IF OLD.permission_type = 'super_admin' AND NEW.permission_type != 'super_admin' THEN
            RAISE EXCEPTION '최고 관리자 권한은 변경할 수 없습니다.';
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Super Admin 권한 검증 트리거
CREATE TRIGGER tr_biu_150_validate_super_admin_permission
    BEFORE INSERT OR UPDATE OF permission_type ON public.users
    FOR EACH ROW
EXECUTE FUNCTION validate_super_admin_permission();


-- File: docker/volumes/db/init/triggers/05-posts/01-create-validation.sql
CREATE OR REPLACE FUNCTION public.posts_create_validation()
    RETURNS TRIGGER AS $$
DECLARE
    v_last_post_time TIMESTAMPTZ;
    v_time_limit INTERVAL := '30 seconds'; -- 기본 제한 시간 30초
    v_time_remaining INTERVAL;
    v_write_level INTEGER;
    v_forbidden_words TEXT[];
    v_today_post_count INTEGER;
    v_daily_post_limit INTEGER;
    v_user_data RECORD;
BEGIN
    -- 제목, 내용 빈값 체크
    IF NEW.title IS NULL OR NEW.title = '' OR NEW.content IS NULL OR NEW.content = '' THEN
        RAISE LOG '제목 또는 내용이 없습니다. %', NEW.writer_id;
        RAISE EXCEPTION '제목 또는 내용이 없습니다.';
    END IF;

    -- 내용 글자수 체크
    IF LENGTH(NEW.content) < 5 THEN
        RAISE EXCEPTION '내용은 5자 이상 작성해주세요.';
    END IF;

    -- 작성자 ID가 없으면 패스 (시스템 작성 글 등)
    IF NEW.writer_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- 사용자 권한 및 활동 레벨 확인
    SELECT u.permission_type, u.activity_level
    INTO v_user_data
    FROM public.users u
    WHERE u.id = NEW.writer_id;

    -- 관리자 및 모더레이터는 제한 없음
    IF v_user_data.permission_type IN ('super_admin', 'admin', 'moderator') THEN
        RETURN NEW;
    END IF;

    -- 게시판 글쓰기 권한 및 금지어 체크
    SELECT
        (b.permission_settings->>'write_level')::INTEGER,
        ARRAY(SELECT jsonb_array_elements_text(b.feature_settings->'forbidden_words'))
    INTO v_write_level, v_forbidden_words
    FROM boards b
    WHERE b.id = NEW.board_id;

    -- 금지어 체크
    IF v_forbidden_words IS NOT NULL AND array_length(v_forbidden_words, 1) > 0 THEN
        IF EXISTS (SELECT 1
                   FROM unnest(v_forbidden_words) AS fw(word)
                   WHERE fw.word IS NOT NULL
                     AND LENGTH(TRIM(fw.word)) > 0
                     AND (POSITION(LOWER(fw.word) IN LOWER(NEW.title)) > 0
                       OR POSITION(LOWER(fw.word) IN LOWER(NEW.content)) > 0)
        ) THEN
            RAISE EXCEPTION '게시글에 금칙어가 포함되어 있습니다.';
        END IF;
    END IF;


    IF COALESCE(v_user_data.activity_level, 0) < COALESCE(v_write_level, 2) THEN
        RAISE EXCEPTION '게시판 글쓰기 권한이 없습니다. (레벨: %, 필요 레벨: %)', v_user_data.activity_level, v_write_level;
    END IF;

    -- 하루 게시글 작성 제한 체크
    SELECT daily_post_limit
    INTO v_daily_post_limit
    FROM public.user_level_configs
    WHERE level = v_user_data.activity_level;

    -- 기본 제한값 설정 (레벨 설정이 없을 경우)
    IF v_daily_post_limit IS NULL THEN
        v_daily_post_limit := 5; -- 기본값
    END IF;

    -- 오늘 작성한 게시글 수 조회
    SELECT COUNT(*) INTO v_today_post_count
    FROM public.posts
    WHERE writer_id = NEW.writer_id
      AND deleted_at IS NULL
      AND created_at >= CURRENT_DATE
      AND created_at < CURRENT_DATE + INTERVAL '1 day';

    -- 하루 게시글 작성 제한 체크
    IF v_today_post_count >= v_daily_post_limit THEN
        RAISE EXCEPTION '하루 게시글 작성 제한 초과: 레벨 %은(는) 하루 최대 %개의 게시글만 작성할 수 있습니다.', v_user_data.activity_level, v_daily_post_limit;
    END IF;

    -- 마지막 게시물 이후 시간 제한 체크
    SELECT created_at
    INTO v_last_post_time
    FROM public.posts
    WHERE writer_id = NEW.writer_id
      AND deleted_at IS NULL
      AND id != NEW.id  -- 현재 삽입/수정하는 게시물 제외
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_last_post_time IS NOT NULL AND NEW.created_at < v_last_post_time + v_time_limit THEN
        v_time_remaining := (v_last_post_time + v_time_limit) - NEW.created_at;
        RAISE EXCEPTION '게시물 작성 간격 제한: 다음 게시물을 작성하기까지 %분 %초 남았습니다.',
            EXTRACT(MINUTE FROM v_time_remaining),
            ROUND(EXTRACT(SECOND FROM v_time_remaining));
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 트리거 재등록
DROP TRIGGER IF EXISTS tr_150_bi_posts_validation ON public.posts;
CREATE TRIGGER tr_150_bi_posts_validation
    BEFORE INSERT ON public.posts
    FOR EACH ROW
EXECUTE FUNCTION posts_create_validation();

-- File: docker/volumes/db/init/triggers/05-posts/09-other-triggers.sql
-- 게시글 작성 시 포인트 지급 트리거 함수
CREATE OR REPLACE FUNCTION posts_point_issue()
    RETURNS TRIGGER
    SET search_path = public
AS
$$
DECLARE
    v_point_amount   numeric;
    v_policy_id      bigint = 1; -- 활동 포인트 정책 ID
    v_board_settings jsonb;
BEGIN
    -- 게시판 포인트 설정 조회
    SELECT point_settings
    INTO v_board_settings
    FROM boards
    WHERE id = NEW.board_id;

    -- 포인트 금액 추출
    v_point_amount := (v_board_settings ->> 'write_post')::numeric;

    -- 포인트가 0보다 큰 경우에만 지급
    IF v_point_amount > 0 THEN
        PERFORM private.points_issue(
                NEW.created_by, -- 사용자 ID
                'ACTIVITY_POINT', -- 포인트 코드
                v_point_amount, -- 포인트 금액
                v_policy_id, -- 정책 ID
                format('게시물 작성 포인트: 게시물 #%s', NEW.id)
                );
    END IF;

    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- 에러 로깅
        INSERT INTO point_error_logs (error_type,
                                      error_message,
                                      user_id,
                                      point_code,
                                      amount,
                                      table_name,
                                      table_record_id,
                                      additional_info)
        VALUES ('ISSUE',
                SQLERRM,
                NEW.created_by,
                'ACTIVITY_POINT',
                v_point_amount,
                'posts',
                NEW.id,
                jsonb_build_object(
                        'source', 'posts_point_issue',
                        'board_id', NEW.board_id,
                        'error_detail', SQLSTATE
                ));
        RETURN NEW; -- 포인트 지급 실패해도 게시글 저장은 진행
END;
$$ LANGUAGE plpgsql;

-- 게시글 작성시 포인트 지급
CREATE TRIGGER tr_260_ai_posts_point_issue
    AFTER INSERT
    ON posts
    FOR EACH ROW
EXECUTE FUNCTION posts_point_issue();



-- File: docker/volumes/db/init/triggers/06-comments/01-create-validation.sql
-- 설명: 댓글 작성 간격 제한 트리거
CREATE OR REPLACE FUNCTION public.comments_check_time_limit()
RETURNS TRIGGER AS $$
DECLARE
    v_last_comment_time TIMESTAMPTZ;
    v_time_limit INTERVAL := '15 seconds'; -- 기본 제한 시간 15초
    v_time_remaining INTERVAL;
    v_error_message TEXT;
    v_comment_level INTEGER;
    v_board_id BIGINT;
    v_user_data RECORD;
BEGIN
    IF length(NEW.content) < 1 THEN
        RAISE EXCEPTION '댓글 내용은 1자 이상 작성해주세요.';
    END IF;

    -- 작성자 ID가 없으면 패스 (비회원 댓글 등)
    IF NEW.writer_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- 사용자 권한 및 활동 레벨 확인
    SELECT u.permission_type, u.activity_level
    INTO v_user_data
    FROM public.users u
    WHERE u.id = NEW.writer_id;

    -- 관리자 및 모더레이터는 제한 없음
    IF v_user_data.permission_type IN ('super_admin', 'admin', 'moderator') THEN
        RETURN NEW;
    END IF;

    -- 댓글이 작성되는 게시글의 게시판 ID 조회
    SELECT p.board_id INTO v_board_id
    FROM public.posts p
    WHERE p.id = NEW.post_id;

    -- 게시판의 댓글 작성 권한 레벨 조회
    SELECT (b.permission_settings->>'comment_level')::INTEGER
    INTO v_comment_level
    FROM boards b
    WHERE b.id = v_board_id;

    -- 사용자의 레벨이 comment_level보다 낮은 경우 권한 없음
    IF COALESCE(v_user_data.activity_level, 0) < COALESCE(v_comment_level, 2) THEN
        RAISE EXCEPTION '댓글 작성 권한이 없습니다. (레벨: %, 필요 레벨: %)', v_user_data.activity_level, v_comment_level;
    END IF;

    -- 해당 사용자의 마지막 댓글 작성 시간 확인
    SELECT created_at INTO v_last_comment_time
    FROM public.comments
    WHERE writer_id = NEW.writer_id
      AND deleted_at IS NULL
      AND id != NEW.id  -- 현재 삽입/수정하는 댓글 제외
    ORDER BY created_at DESC
    LIMIT 1;

    -- 마지막 댓글 작성 후 제한 시간이 지났는지 확인
    IF v_last_comment_time IS NOT NULL AND
       NEW.created_at < v_last_comment_time + v_time_limit THEN

        v_time_remaining := (v_last_comment_time + v_time_limit) - NEW.created_at;

        RAISE EXCEPTION '댓글 작성 간격 제한: 다음 댓글을 작성하기까지 %분 %초 남았습니다.',
            EXTRACT(MINUTE FROM v_time_remaining),
            ROUND(EXTRACT(SECOND FROM v_time_remaining));
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 트리거 등록
DROP TRIGGER IF EXISTS tr_bi_150_comments_time_limit ON public.comments;
CREATE TRIGGER tr_bi_150_comments_time_limit
    BEFORE INSERT ON public.comments
    FOR EACH ROW
    EXECUTE FUNCTION comments_check_time_limit();

COMMENT ON FUNCTION comments_check_time_limit() IS '댓글 작성 간격 제한을 확인하는 함수';
COMMENT ON TRIGGER tr_bi_150_comments_time_limit ON public.comments IS '댓글 작성 간격 제한 트리거';


-- File: docker/volumes/db/init/triggers/06-comments/02-update-post-comment-count.sql
-- 수정된 게시글 댓글 수 업데이트 함수
CREATE OR REPLACE FUNCTION posts_update_comment_count()
    RETURNS TRIGGER
    SECURITY DEFINER
AS $$
DECLARE
    v_post_id BIGINT;
    v_old_deleted_at TIMESTAMPTZ;
    v_new_deleted_at TIMESTAMPTZ;
BEGIN
    -- INSERT 처리: 새 댓글 생성
    IF TG_OP = 'INSERT' THEN
        UPDATE public.posts
        SET comment_count = comment_count + 1,
            updated_at = now()
        WHERE id = NEW.post_id;

        RAISE LOG '댓글 추가: post_id=%, comment_id=%, 새 카운트 반영', NEW.post_id, NEW.id;
        RETURN NEW;
    END IF;

    -- DELETE 처리: 물리적 삭제 (거의 사용되지 않을 것으로 예상)
    IF TG_OP = 'DELETE' THEN
        -- 삭제되지 않았던 댓글이 물리적으로 삭제되는 경우에만 카운트 감소
        IF OLD.deleted_at IS NULL THEN
            UPDATE public.posts
            SET comment_count = GREATEST(0, comment_count - 1),
                updated_at = now()
            WHERE id = OLD.post_id;

            RAISE LOG '댓글 물리적 삭제: post_id=%, comment_id=%, 카운트 감소', OLD.post_id, OLD.id;
        END IF;

        RETURN OLD;
    END IF;

    -- UPDATE 처리: soft delete 처리
    IF TG_OP = 'UPDATE' THEN
        v_old_deleted_at := OLD.deleted_at;
        v_new_deleted_at := NEW.deleted_at;
        v_post_id := COALESCE(NEW.post_id, OLD.post_id);

        -- deleted_at 필드가 변경된 경우에만 처리
        IF v_old_deleted_at IS DISTINCT FROM v_new_deleted_at THEN
            -- NULL에서 값으로 변경 (댓글 삭제)
            IF v_old_deleted_at IS NULL AND v_new_deleted_at IS NOT NULL THEN
                UPDATE public.posts
                SET comment_count = GREATEST(0, comment_count - 1),
                    updated_at = now()
                WHERE id = v_post_id;

                RAISE LOG '댓글 soft delete: post_id=%, comment_id=%, 카운트 감소', v_post_id, NEW.id;

                -- 값에서 NULL로 변경 (댓글 복구)
            ELSIF v_old_deleted_at IS NOT NULL AND v_new_deleted_at IS NULL THEN
                UPDATE public.posts
                SET comment_count = comment_count + 1,
                    updated_at = now()
                WHERE id = v_post_id;

                RAISE LOG '댓글 복구: post_id=%, comment_id=%, 카운트 증가', v_post_id, NEW.id;
            END IF;
        END IF;

        RETURN NEW;
    END IF;

    RETURN COALESCE(NEW, OLD);

EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG '댓글 카운트 업데이트 오류: operation=%, post_id=%, comment_id=%, error=%',
            TG_OP, v_post_id, COALESCE(NEW.id, OLD.id), SQLERRM;
        -- 에러가 발생해도 댓글 작업은 계속 진행되도록 함
        RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- 기존 트리거 삭제
DROP TRIGGER IF EXISTS tr_150_ai_comments_update_post_comment_count ON public.comments;

-- 새로운 트리거 생성 (INSERT, UPDATE, DELETE 모두 처리)
CREATE TRIGGER tr_150_ai_comments_update_post_comment_count
    AFTER INSERT OR UPDATE OF deleted_at OR DELETE
    ON public.comments
    FOR EACH ROW
EXECUTE FUNCTION posts_update_comment_count();

-- File: docker/volumes/db/init/triggers/06-comments/09-other-triggers.sql
-- 댓글 작성 시 포인트 지급 트리거 함수
CREATE OR REPLACE FUNCTION comments_point_issue()
    RETURNS TRIGGER
    SET search_path = public
AS
$$
DECLARE
    v_point_amount   numeric;
    v_policy_id      bigint = 1; -- 활동 포인트 정책 ID
    v_board_settings jsonb;
    v_board_id       bigint;
BEGIN
    -- 댓글이 달린 게시글의 게시판 ID 조회
    SELECT board_id
    INTO v_board_id
    FROM posts
    WHERE id = NEW.post_id;

    -- 게시판 포인트 설정 조회
    SELECT point_settings
    INTO v_board_settings
    FROM boards
    WHERE id = v_board_id;

    -- 포인트 금액 추출
    v_point_amount := (v_board_settings ->> 'write_comment')::numeric;

    -- 포인트가 0보다 큰 경우에만 지급
    IF v_point_amount > 0 THEN
        PERFORM private.points_issue(
                NEW.writer_id, -- 사용자 ID
                'ACTIVITY_POINT', -- 포인트 코드
                v_point_amount, -- 포인트 금액
                v_policy_id, -- 정책 ID
                format('댓글 작성 포인트: 댓글 #%s)', NEW.id)
                );
    END IF;

    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- 에러 로깅
        INSERT INTO point_error_logs (error_type,
                                      error_message,
                                      user_id,
                                      point_code,
                                      amount,
                                      table_name,
                                      table_record_id,
                                      additional_info)
        VALUES ('ISSUE',
                SQLERRM,
                NEW.writer_id,
                'ACTIVITY_POINT',
                v_point_amount,
                'comments',
                NEW.id,
                jsonb_build_object(
                        'source', 'comments_point_issue',
                        'post_id', NEW.post_id,
                        'board_id', v_board_id,
                        'error_detail', SQLSTATE
                ));
        RETURN NEW; -- 포인트 지급 실패해도 댓글 저장은 진행
END;
$$ LANGUAGE plpgsql;


-- 댓글 작성시 포인트 지급
CREATE TRIGGER tr_260_comments_z_point_issue
    AFTER INSERT
    ON comments
    FOR EACH ROW
EXECUTE FUNCTION comments_point_issue();

-- File: docker/volumes/db/init/triggers/08-reactions/02-update-post-reaction-count.sql
CREATE OR REPLACE FUNCTION reactions_count_update()
    RETURNS TRIGGER
    SECURITY DEFINER
AS $$
    DECLARE
BEGIN
    -- 게시글 반응 카운트 업데이트
    IF NEW.reaction_type = 'like' THEN
        IF NEW.target_type = 'post' THEN
            UPDATE public.posts SET like_count = like_count + 1 WHERE id = NEW.target_id;
        ELSE
            UPDATE public.comments SET like_count = like_count + 1 WHERE id = NEW.target_id;
        END IF;
    ELSE
        IF NEW.target_type = 'post' THEN
            UPDATE public.posts SET dislike_count = dislike_count + 1 WHERE id = NEW.target_id;
        ELSE
            UPDATE public.comments SET dislike_count = dislike_count + 1 WHERE id = NEW.target_id;
        END IF;
    END if;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_150_ai_reactions_count_update ON public.reactions;
CREATE TRIGGER tr_150_ai_reactions_count_update
    AFTER INSERT OR UPDATE ON public.reactions
    FOR EACH ROW
EXECUTE FUNCTION reactions_count_update();

-- File: docker/volumes/db/init/triggers/08-reactions/03-update-reaction-prevent.sql
-- 트리거 함수 생성
CREATE OR REPLACE FUNCTION reactions_prevent_update()
    RETURNS TRIGGER AS $$
BEGIN
    RAISE LOG '좋아요/싫어요 표시는 변경할 수 없습니다. from % to %', OLD.reaction_type, NEW.reaction_type;
    RAISE EXCEPTION '좋아요/싫어요 표시는 변경할 수 없습니다.';
END;
$$ LANGUAGE plpgsql;

-- 트리거 생성
CREATE TRIGGER tr_200_bu_reactions_prevent_update
    BEFORE UPDATE ON reactions
    FOR EACH ROW
EXECUTE FUNCTION reactions_prevent_update();

-- 트리거 코멘트 추가
COMMENT ON TRIGGER tr_200_bu_reactions_prevent_update ON reactions IS
    'Prevents changing reaction_type once it has been set to like or dislike';

-- File: docker/volumes/db/init/triggers/08-reactions/09-other-triggers.sql
-- 리액션에 따른 포인트 증감/차감
CREATE TRIGGER tr_260_ai_reactions_point_process
    AFTER INSERT
    ON reactions
    FOR EACH ROW
EXECUTE FUNCTION reactions_point_process();

-- File: docker/volumes/db/init/triggers/14-points/01-user-level-update.sql
-- AFTER UPDATE ONLY TRIGGER for user_point_wallets
CREATE OR REPLACE FUNCTION public.user_point_wallets_level_update()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
DECLARE
    v_user_id BIGINT := NEW.user_id;
    v_current_user_level INTEGER;
    v_old_balance NUMERIC := OLD.balance;
    v_new_balance NUMERIC := NEW.balance;
    v_new_level INTEGER;
    v_updated_rows INTEGER;
    v_balance_change NUMERIC;
BEGIN
    -- ACTIVITY_POINT가 아닌 경우 처리하지 않음
    IF NEW.point_code != 'ACTIVITY_POINT' THEN
        RETURN NEW;
    END IF;

    -- 실제로 balance가 변경되지 않은 경우 처리하지 않음 (성능 최적화)
    IF v_old_balance = v_new_balance THEN
        RETURN NEW;
    END IF;

    -- 변경량 계산 (로깅용)
    v_balance_change := v_new_balance - v_old_balance;

    -- 현재 사용자 레벨 조회
    SELECT activity_level INTO v_current_user_level
    FROM users
    WHERE id = v_user_id;

    -- 사용자가 존재하지 않는 경우 처리 중단
    IF NOT FOUND THEN
        RAISE LOG 'user_point_wallets_level_update: 사용자를 찾을 수 없음 (user_id: %)', v_user_id;
        RETURN NEW;
    END IF;

    -- 기본값 설정 (레벨이 NULL인 경우)
    v_current_user_level := COALESCE(v_current_user_level, 1);

    -- 새로운 포인트 잔액 기반으로 레벨 계산
    IF v_new_balance < 0 THEN
        -- 포인트가 음수인 경우 레벨 0
        v_new_level := 0;
    ELSE
        -- 현재 포인트로 달성 가능한 최고 레벨 계산
        SELECT COALESCE(
                       (SELECT level
                        FROM user_level_configs
                        WHERE required_points <= v_new_balance
                        ORDER BY level DESC
                        LIMIT 1),
                       1  -- 조건에 맞는 레벨이 없으면 기본 레벨 1
               ) INTO v_new_level;
    END IF;

    -- 레벨이 변경된 경우에만 업데이트
    IF v_new_level != v_current_user_level THEN
        UPDATE users
        SET activity_level = v_new_level,
            updated_at = now()
        WHERE id = v_user_id;

        -- 업데이트된 행 수 확인
        GET DIAGNOSTICS v_updated_rows = ROW_COUNT;

        IF v_updated_rows > 0 THEN
            -- 레벨 변경 로그 (업/다운 구분, 포인트 변경량 포함)
            IF v_new_level > v_current_user_level THEN
                RAISE LOG 'user_point_wallets_level_update: 레벨 업 - user_id=%, %→% (포인트: %→%, 변경량: %+), 시간=%',
                    v_user_id, v_current_user_level, v_new_level,
                    v_old_balance, v_new_balance, v_balance_change, now();
            ELSIF v_new_level < v_current_user_level THEN
                RAISE LOG 'user_point_wallets_level_update: 레벨 다운 - user_id=%, %→% (포인트: %→%, 변경량: %), 시간=%',
                    v_user_id, v_current_user_level, v_new_level,
                    v_old_balance, v_new_balance, v_balance_change, now();
            END IF;
        ELSE
            RAISE LOG 'user_point_wallets_level_update: 레벨 업데이트 실패 - user_id=%, 대상_레벨=%',
                v_user_id, v_new_level;
        END IF;
    ELSE
        -- 레벨 변경이 없더라도 큰 포인트 변동이 있으면 로깅 (선택적)
        IF ABS(v_balance_change) >= 1000 THEN
            RAISE LOG 'user_point_wallets_level_update: 대량 포인트 변동 (레벨 변경 없음) - user_id=%, 레벨=%, 포인트: %→%, 변경량: %',
                v_user_id, v_current_user_level, v_old_balance, v_new_balance, v_balance_change;
        END IF;
    END IF;

    RETURN NEW;

EXCEPTION
    WHEN OTHERS THEN
        -- 전체 함수 실패 시 로그 남기고 NEW 반환하여 원본 트랜잭션은 유지
        RAISE LOG 'user_point_wallets_level_update: 치명적 오류 - user_id=%, 포인트변경: %→%, error=%',
            v_user_id, v_old_balance, v_new_balance, SQLERRM;
        RETURN NEW;
END;
$$;

-- 트리거 생성 (UPDATE만 처리)
DROP TRIGGER IF EXISTS tr_200_au_user_point_wallets_level_update ON public.user_point_wallets;
CREATE TRIGGER tr_200_au_user_point_wallets_level_update
    AFTER UPDATE OF balance
    ON public.user_point_wallets
    FOR EACH ROW
EXECUTE FUNCTION public.user_point_wallets_level_update();


-- =======================================
-- ROW LEVEL SECURITY POLICIES
-- =======================================

-- File: docker/volumes/db/init/policies/00-global-policies.sql
CREATE POLICY "Public bucket Retrieve" ON storage.objects
    FOR SELECT TO authenticated
    USING (true);

CREATE POLICY "Public bucket insert" ON storage.objects
    FOR INSERT TO authenticated
    WITH CHECK (bucket_id = 'public-bucket');

CREATE POLICY "Individual user Access" on storage.objects
    FOR SELECT TO authenticated
    USING ( (SELECT auth.uid()) = owner::uuid );

-- File: docker/volumes/db/init/policies/01-users-policies.sql
-- 설명: 사용자 테이블에 대한 RLS 정책

-- RLS 활성화 재확인
alter table public.users enable row level security;

-- 기본 정책: 삭제된 사용자 제외
create policy "Exclude deleted users" on public.users
    as restrictive
    for all
    using (deleted_at is null);

-- 관리자는 모든 작업 가능
create policy "Enable all for admins" on public.users
    as permissive
    for all
    using (is_admin());

-- 일반 유저는 조회 가능
create policy "Enable read for user" on public.users
    as permissive
    for select
    using (true);

-- 본인 데이터 수정
create policy "Enable update for own user" on public.users
    as permissive
    for update
    using (id = get_user_id_from_auth_uid())
    with check (id = get_user_id_from_auth_uid());

-- user_blocks 테이블에 대한 RLS 정책

-- RLS 활성화
ALTER TABLE public.user_blocks ENABLE ROW LEVEL SECURITY;

-- 사용자는 자신이 차단한 목록을 볼 수 있음
CREATE POLICY "Allow users to view their blocks" ON public.user_blocks
    FOR SELECT
    USING (blocker_user_id = get_user_id_from_auth_uid());

-- 사용자는 자신의 차단만 생성 가능
CREATE POLICY "Allow users to create blocks" ON public.user_blocks
    FOR INSERT
    WITH CHECK (blocker_user_id = get_user_id_from_auth_uid());

-- 사용자는 자신이 생성한 차단만 수정 가능
CREATE POLICY "Allow users to update their blocks" ON public.user_blocks
    FOR UPDATE
    USING (blocker_user_id = get_user_id_from_auth_uid())
    WITH CHECK (blocker_user_id = get_user_id_from_auth_uid());

-- 사용자는 자신이 생성한 차단만 삭제 가능
CREATE POLICY "Allow users to delete their blocks" ON public.user_blocks
    FOR DELETE
    USING (blocker_user_id = get_user_id_from_auth_uid());

-- 관리자는 모든 차단 내역 조회 가능
CREATE POLICY "Allow admins to view all blocks" ON public.user_blocks
    FOR SELECT
    USING (is_admin());

-- 관리자는 모든 차단 내역 수정 가능
CREATE POLICY "Allow admins to update all blocks" ON public.user_blocks
    FOR UPDATE
    USING (is_admin())
    WITH CHECK (is_admin());

-- 관리자는 모든 차단 내역 삭제 가능
CREATE POLICY "Allow admins to delete all blocks" ON public.user_blocks
    FOR DELETE
    USING (is_admin());

-- File: docker/volumes/db/init/policies/02-site-configs-policies.sql
-- 파일: 02-site-configs-policies.sql
-- 설명: 사이트 설정 테이블 RLS 정책

ALTER TABLE site_config_kv ENABLE ROW LEVEL SECURITY;

-- 모든 사용자가 설정값을 조회할 수 있음
CREATE POLICY "유저 조회 권한" ON site_config_kv
    FOR SELECT
    USING (true);

-- 관리자만 설정값을 수정할 수 있음
CREATE POLICY "관리자 권한" ON site_config_kv
    FOR ALL
    USING (is_admin());


-- File: docker/volumes/db/init/policies/03-blocked-ips-policies.sql
-- 파일: 03-blocked-ips-policies.sql
-- 설명: IP 차단 테이블 RLS 정책
-- 의존성: 
--   schema/02-tables/03-blocked-ips.sql (blocked_ips 테이블)
--   functions/02-users/01-users-utility.sql (is_admin 함수)

-- RLS 정책 설정
alter table public.blocked_ips
    enable row level security;

-- 관리자만 조회 가능하도록 정책 설정
create policy "Allow read for admins" on public.blocked_ips
    for select using (public.is_admin());

-- 관리자만 추가/수정/삭제 가능하도록 정책 설정
create policy "Allow insert for admins" on public.blocked_ips
    for insert with check (public.is_admin());

create policy "Allow update for admins" on public.blocked_ips
    for update
    using (public.is_admin());

create policy "Allow delete for admins" on public.blocked_ips
    for delete
    using (public.is_admin());


-- File: docker/volumes/db/init/policies/04-boards-policies.sql
-- 파일: 04-boards-policies.sql
-- 설명: 게시판 테이블 RLS 정책
-- 의존성: 
--   schema/02-tables/04-boards.sql (boards, board_users 테이블)
--   functions/02-users/01-users-utility.sql (is_admin, get_user_id_from_auth_uid 함수)

------------------------------------------------------------------------------
--- SETTING UP POLICIES ---
------------------------------------------------------------------------------
-- boards 테이블 RLS 활성화
alter table public.boards
    enable row level security;

-- 삭제되지 않은 게시판만 접근 가능
create policy "Exclude deleted boards" on public.boards
    as restrictive
    for all
    using (deleted_at is null);

-- 관리자는 모든 게시판에 대한 모든 권한을 가짐
create policy "Enable all for admins" on public.boards
    as permissive
    for all
    using (public.is_admin());

-- public 게시판은 모든 사용자가 조회 가능
create policy "Enable read for public boards" on public.boards
    as permissive
    for select
    using (
    visibility = 'public'
        and is_active = true
    );

-- private 게시판은 인증된 사용자만 조회 가능
create policy "Enable read for private boards" on public.boards
    as permissive
    for select
    using (
    visibility = 'private'
        and is_active = true
        and auth.role() = 'authenticated'
    );

-- hidden 게시판은 멤버만 조회 가능
create policy "Enable read for hidden boards" on public.boards
    as permissive
    for select
    using (
    visibility = 'hidden'
        and is_active = true
        and exists (select 1
                    from board_users
                    where board_id = boards.id
                      and user_id = get_user_id_from_auth_uid()
                      and deleted_at is null)
    );

-- board_users 테이블 RLS 활성화
alter table public.board_users
    enable row level security;

-- board_users 테이블에 대한 RLS 정책
create policy "Enable read for board members" on public.board_users
    as permissive
    for select
    using (
    deleted_at is null
        and (
        -- 게시판 관리자
        public.is_admin()
            -- 또는 게시판 멤버
            or user_id = get_user_id_from_auth_uid()
        )
    );

-- RLS 정책 추가
ALTER TABLE board_categories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable read for all users"
    ON board_categories FOR SELECT
    USING (deleted_at IS NULL);

CREATE POLICY "Enable administration for admins"
    ON board_categories FOR ALL
    USING (is_admin());

-- File: docker/volumes/db/init/policies/05-posts-policies.sql
-- 설명: 게시글관련 테이블에 대한 RLS 정책

-- RLS 활성화 재확인
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "유저 접근 권한 체크" ON public.posts
    FOR SELECT
    USING (
    is_secret = false
        AND deleted_at IS NULL
        AND status = 'published'
        AND (
        -- 현재 사용자 레벨 vs 게시판 요구 레벨 비교 (한 번에 처리)
        COALESCE(
                (SELECT u.activity_level
                 FROM public.users u
                 WHERE u.id = get_user_id_from_auth_uid()),
                0  -- 익명 사용자는 레벨 0
        ) >=
        (SELECT COALESCE((permission_settings->>'list_level')::integer, 0)
         FROM public.boards
         WHERE id = posts.board_id)
        )
    );

CREATE POLICY "allow access to owned posts" ON public.posts
    FOR SELECT
    USING ((writer_id = public.get_user_id_from_auth_uid() OR public.is_admin()));

-- 게시글 생성 정책
CREATE POLICY "allow creation of posts" ON public.posts
    FOR INSERT
    WITH CHECK (public.get_user_id_from_auth_uid() IS NOT NULL);

-- 게시글 수정 정책
-- 자신이 작성한 게시글만 수정 가능, 관리자는 모든 게시글 수정 가능
CREATE POLICY "allow update of posts" ON public.posts
    FOR UPDATE
    USING (writer_id = public.get_user_id_from_auth_uid() OR public.is_admin());

-- 게시글 삭제 정책
-- 자신이 작성한 게시글만 삭제 가능, 관리자는 모든 게시글 삭제 가능
CREATE POLICY "allow deletion of posts" ON public.posts
    FOR DELETE
    USING (writer_id = public.get_user_id_from_auth_uid() OR public.is_admin());

--- 북마크 관련

-- RLS 정책 설정: 사용자 본인의 폴더만 관리(CRUD) 허용
ALTER TABLE public.bookmark_folders ENABLE ROW LEVEL SECURITY;

-- SELECT, UPDATE, DELETE에 대한 정책
CREATE POLICY "Allow individual user access"
    ON public.bookmark_folders
    FOR SELECT
    USING (public.get_user_id_from_auth_uid() = user_id);

CREATE POLICY "Allow individual user update"
    ON public.bookmark_folders
    FOR UPDATE
    USING (public.get_user_id_from_auth_uid() = user_id);

CREATE POLICY "Allow individual user delete"
    ON public.bookmark_folders
    FOR DELETE
    USING (public.get_user_id_from_auth_uid() = user_id);

-- INSERT에 대한 별도 정책
CREATE POLICY "Allow user to create own folders"
    ON public.bookmark_folders
    FOR INSERT
    WITH CHECK (public.get_user_id_from_auth_uid() IS NOT NULL);

-- 관리자는 모든 북마크 폴더에 대한 CRUD 권한을 가짐
CREATE POLICY "Allow admins to access all bookmark folders"
    ON public.bookmark_folders
    FOR ALL
    USING (public.is_admin())
    WITH CHECK (public.is_admin());

-- post_bookmarks 테이블 RLS 설정 (이미 있으면 스킵)
-- RLS 정책 설정
ALTER TABLE public.post_bookmarks ENABLE ROW LEVEL SECURITY;

-- 정책: 사용자 본인의 북마크만 조회 허용
CREATE POLICY "Allow individual user select access"
    ON public.post_bookmarks
    FOR SELECT
    USING (public.get_user_id_from_auth_uid() = user_id);

-- 정책: 사용자 본인의 북마크만 추가(INSERT) 허용
-- 추가로, 삽입하려는 folder_id가 본인 소유인지 확인하는 것이 더 안전하지만,
-- bookmark_folders 테이블의 RLS와 FK 제약으로 인해 간접적으로 방지될 가능성이 높음.
-- 필요 시 WITH CHECK 절에 서브쿼리로 folder 소유권 확인 로직 추가 가능.
CREATE POLICY "Allow individual user insert"
    ON public.post_bookmarks
    FOR INSERT
    WITH CHECK (public.get_user_id_from_auth_uid() IS NOT NULL);

-- 정책: 사용자 본인의 북마크만 수정(UPDATE) 허용 (예: 폴더 이동)
CREATE POLICY "Allow individual user update"
    ON public.post_bookmarks
    FOR UPDATE
    USING (public.get_user_id_from_auth_uid() = user_id)
    WITH CHECK (public.get_user_id_from_auth_uid() = user_id);

-- 정책: 사용자 본인의 북마크만 삭제 허용
CREATE POLICY "Allow individual user delete"
    ON public.post_bookmarks
    FOR DELETE
    USING (public.get_user_id_from_auth_uid() = user_id);


-- File: docker/volumes/db/init/policies/06-comments-policies.sql
-- 설명: 댓글 테이블에 대한 RLS 정책

-- RLS 활성화 재확인
alter table public.comments enable row level security;

-- 기본 정책: 삭제되지 않은 댓글만 접근 가능 (모든 작업에 적용)
create policy "allow access to non-deleted comments" on public.comments
    as restrictive
    for all
    using (deleted_at is null);

-- 댓글 조회 정책
-- 1. 모든 사용자는 게시글에 달린 댓글을 볼 수 있음 (단, 연결된 게시글이 공개 상태인 경우)
create policy "allow view comments on public posts" on public.comments
    for select
    using (
    exists (
        select 1 from public.posts p
        where p.id = post_id
          and p.is_secret = false
          and p.deleted_at is null
    )
    );

-- 2. 비밀 게시글의 댓글은 작성자와 관리자만 조회 가능
create policy "allow view comments on secret posts" on public.comments
    for select
    using (
    exists (
        select 1 from public.posts p
        where p.id = post_id
          and p.is_secret = true
          and (p.writer_id = get_user_id_from_auth_uid() OR public.is_admin())
          and p.deleted_at is null
    )
    );

create policy "allow creation of comments" on public.comments
    for insert
    with check (get_user_id_from_auth_uid() IS NOT NULL);

SELECT * FROM pg_policies WHERE tablename = 'comments';

create policy "allow update of comments for user" on public.comments
    for update
    using (writer_id = get_user_id_from_auth_uid() OR public.is_admin());

create policy "allow delete of comments" on public.comments
    for delete
    using (writer_id = get_user_id_from_auth_uid() OR public.is_admin());

-- File: docker/volumes/db/init/policies/09-menu-policies.sql
ALTER TABLE public.menu ENABLE ROW LEVEL SECURITY;

CREATE POLICY "유저 조회 권한" ON public.menu
    FOR SELECT
    USING (deleted_at IS NULL);

CREATE POLICY "관리자 권한" ON public.menu
    FOR ALL
    WITH CHECK (is_admin());

-- File: docker/volumes/db/init/policies/10-repots-policies.sql
-- 파일: policies/10-reports-policies.sql
-- 설명: 신고 관련 테이블 RLS 정책

-- RLS 활성화
ALTER TABLE public.report_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

-- 신고 유형 테이블 정책
-- 모든 사용자가 활성화된 신고 유형을 조회할 수 있음
CREATE POLICY "report_types_select_policy" ON public.report_types
    FOR SELECT
    USING (is_active = true);

-- 관리자만 신고 유형을 관리할 수 있음
CREATE POLICY "report_types_admin_policy" ON public.report_types
    FOR ALL
    USING (public.is_admin())
    WITH CHECK (public.is_admin());

-- 신고 내역 테이블 정책
-- 일반 사용자는 자신이 신고한 내역만 조회 가능
CREATE POLICY "reports_select_own_policy" ON public.reports
    FOR SELECT
    USING (reporter_id = get_user_id_from_auth_uid() AND deleted_at IS NULL);

-- 관리자는 모든 신고 내역을 관리할 수 있음
CREATE POLICY "reports_admin_policy" ON public.reports
    FOR ALL
    USING (public.is_admin())
    WITH CHECK (public.is_admin());

-- 일반 사용자는 신고를 생성할 수 있음
CREATE POLICY "reports_insert_policy" ON public.reports
    FOR INSERT
    WITH CHECK (reporter_id = get_user_id_from_auth_uid());

-- File: docker/volumes/db/init/policies/14-points-policies.sql
ALTER TABLE public.user_point_wallets ENABLE ROW LEVEL SECURITY;

-- 일반 사용자가 자신의 포인트를 조회할 수 있도록 하는 정책
CREATE POLICY "Allow users to select their own wallets" ON public.user_point_wallets
    FOR SELECT
    USING (user_id = get_user_id_from_auth_uid());

-- CREATE POLICY "관리자 권한" ON public.user_point_wallets
--     FOR ALL
--     USING (is_admin());
--
-- CREATE POLICY "유저 쓰기 권한" ON public.user_point_wallets
--     FOR INSERT
--     WITH CHECK (user_id = get_user_id_from_auth_uid());
--
-- CREATE POLICY "유저 수정 권한" ON public.user_point_wallets
--     FOR UPDATE
--     WITH CHECK (user_id = get_user_id_from_auth_uid());
--
-- ALTER TABLE public.point_codes ENABLE ROW LEVEL SECURITY;
--
-- CREATE POLICY "관리자 권한" ON public.point_codes
--     FOR ALL
--     USING (is_admin());
--
-- CREATE POLICY "유저 읽기 권한" ON public.point_codes
--     FOR SELECT
--     USING (true);
--
-- ALTER TABLE public.point_error_logs ENABLE ROW LEVEL SECURITY;
--
-- CREATE POLICY "관리자 권한" ON public.point_error_logs
--     FOR ALL
--     USING (is_admin());
--
-- CREATE POLICY "유저 읽기 권한" ON public.point_error_logs
--     FOR SELECT
--     USING (user_id = get_user_id_from_auth_uid());
--
-- CREATE POLICY "유저 쓰기 권한" ON public.point_error_logs
--     FOR INSERT
--     WITH CHECK (user_id = get_user_id_from_auth_uid());
--
-- ALTER TABLE public.point_expiration_logs ENABLE ROW LEVEL SECURITY;
--
-- CREATE POLICY "관리자 권한" ON public.point_expiration_logs
--     FOR ALL
--     USING (is_admin());
--
-- ALTER TABLE public.point_policies ENABLE ROW LEVEL SECURITY;
--
-- CREATE POLICY "관리자 권한" ON public.point_policies
--     FOR ALL
--     USING (is_admin());
--
-- CREATE POLICY "유저 읽기 권한" ON public.point_policies
--     FOR SELECT
--     USING (true);
--
ALTER TABLE public.point_transactions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "관리자 권한" ON public.point_transactions
    FOR ALL
    USING (is_admin());

CREATE POLICY "유저 읽기 권한" ON public.point_transactions
    FOR SELECT
    USING (user_id = get_user_id_from_auth_uid());

CREATE POLICY "유저 쓰기 권한" ON public.point_transactions
    FOR INSERT
    WITH CHECK (user_id = get_user_id_from_auth_uid());

-- File: docker/volumes/db/init/policies/15-notifications-policies.sql
-- 파일: 15-notifications-policies.sql
-- 설명: 알림 관련 정책 정의
-- 의존성:
--   schema/02-tables/15-notifications.sql (notification_templates, user_notifications 테이블)
--   functions/01-utility (get_user_id_from_auth_uid 함수)

-- 알림 템플릿 정책
create policy "Enable read access for all users" on public.notification_templates
    as permissive
    for select
    using (true);

-- 사용자 알림 내역 정책
create policy "Enable read access for all users" on public.user_notifications
    as permissive
    for select
    using (true);

create policy "Enable All for users based on user_id" on public.user_notifications
    as permissive
    for all
    using (user_id = get_user_id_from_auth_uid())
    with check (user_id = get_user_id_from_auth_uid());

-- File: docker/volumes/db/init/policies/16-banners-policies.sql
-- RLS 활성화
ALTER TABLE public.banners ENABLE ROW LEVEL SECURITY;

-- 모든 사용자가 조회 가능하도록 설정
CREATE POLICY "Enable read access for all users" ON public.banners
    AS PERMISSIVE
    FOR SELECT
    USING (
    status = 'ACTIVE' AND
    start_at <= CURRENT_TIMESTAMP AND
    end_at >= CURRENT_TIMESTAMP
    );

-- 관리자만 모든 배너 조회 가능
CREATE POLICY "Enable all read access for admins" ON public.banners
    AS PERMISSIVE
    FOR SELECT
    USING (public.is_admin());

-- 관리자만 추가/수정/삭제 가능하도록 설정
CREATE POLICY "Enable insert for admins" ON public.banners
    AS PERMISSIVE
    FOR INSERT
    WITH CHECK (public.is_admin());

CREATE POLICY "Enable update for admins" ON public.banners
    AS PERMISSIVE
    FOR UPDATE
    USING (public.is_admin());

CREATE POLICY "Enable delete for admins" ON public.banners
    AS PERMISSIVE
    FOR DELETE
    USING (public.is_admin());

-- File: docker/volumes/db/init/policies/19-challenge-policies.sql
ALTER TABLE public.challenge_codes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "관리자 권한" ON public.challenge_codes
    FOR ALL
    USING (is_admin());

CREATE POLICY "사용자 읽기 권한" ON public.challenge_codes
    FOR SELECT
    USING (is_active = true);

ALTER TABLE public.challenge_action_types ENABLE ROW LEVEL SECURITY;

CREATE POLICY "관리자 권한" ON public.challenge_action_types
    FOR ALL
    USING (is_admin());

CREATE POLICY "사용자 읽기 권한" ON public.challenge_action_types
    FOR SELECT
    USING (is_active = true);

ALTER TABLE public.challenge_types ENABLE ROW LEVEL SECURITY;

CREATE POLICY "관리자 권한" ON public.challenge_types
    FOR ALL
    USING (is_admin());

CREATE POLICY "사용자 읽기 권한" ON public.challenge_types
    FOR SELECT
    USING (is_active = true);

ALTER TABLE public.challenges ENABLE ROW LEVEL SECURITY;

CREATE POLICY "관리자 권한" ON public.challenges
    FOR ALL
    USING (is_admin());

CREATE POLICY "사용자 읽기 권한" ON public.challenges
    FOR SELECT
    USING (is_active = true);

ALTER TABLE public.user_challenge_progress ENABLE ROW LEVEL SECURITY;

CREATE POLICY "관리자 권한" ON user_challenge_progress
    FOR ALL
    USING (is_admin());

CREATE POLICY "사용자 읽기 권한" ON user_challenge_progress
    FOR SELECT
    USING (user_id = get_user_id_from_auth_uid());

CREATE POLICY "사용자 쓰기 권한" ON user_challenge_progress
    FOR INSERT
    WITH CHECK (user_id = get_user_id_from_auth_uid());

CREATE POLICY "사용자 수정 권한" ON user_challenge_progress
    FOR UPDATE
    WITH CHECK (user_id = get_user_id_from_auth_uid());


-- =======================================
-- INITIAL DATA
-- =======================================

-- File: docker/volumes/db/init/data/data.sql
-- 필수 함수 사후 업데이트
-- 필수 함수를 최초 생성시 auth.jwt() 참조가 불가능해서 주석처리하여 생성하여 다른 쿼리들이 참조하도록 만듦.
-- 서비스 최초 실행시에 주석처리된 함수로 생성하고 마지막에 이 data.sql 파일에서 업데이트하여 주석을 해제함.
CREATE OR REPLACE FUNCTION get_user_id_from_auth_uid() RETURNS bigint
    SECURITY DEFINER
    SET search_path = public, auth
    LANGUAGE sql
    STABLE
AS $$
SELECT COALESCE(
           -- JWT에서 먼저 시도 (0.1ms 미만)
                   (auth.jwt() ->> 'user_id')::bigint,
           -- 없으면 DB에서 조회 (fallback)
               (SELECT u.id FROM public.users u WHERE u.auth_user_id = auth.uid() LIMIT 1)
       );
$$;

CREATE OR REPLACE FUNCTION get_nickname_from_auth_uid()
    RETURNS text
    LANGUAGE sql
    STABLE
    SECURITY DEFINER
AS $$
SELECT COALESCE(
               auth.jwt() ->> 'nickname',
               (SELECT u.nickname FROM public.users u WHERE u.auth_user_id = auth.uid() LIMIT 1)
       );
$$;

CREATE OR REPLACE FUNCTION is_admin()
    RETURNS boolean
    LANGUAGE sql
    STABLE
    SECURITY DEFINER
AS $$
SELECT COALESCE(
               (auth.jwt() ->> 'is_admin')::boolean,
               EXISTS (
                   SELECT 1 FROM public.users u
                   WHERE u.auth_user_id = auth.uid()
                     AND u.permission_type IN ('super_admin', 'admin')
               )
       );
$$;

-- 테이블에 생성 Audit 트리거 생성
DO
$$
    DECLARE
        t record;
    BEGIN
        FOR t IN
            SELECT table_name
            FROM information_schema.columns c
            WHERE c.table_schema = 'public'
              AND c.table_name IN (SELECT table_name
                                   FROM information_schema.tables
                                   WHERE table_schema = 'public'
                                     AND table_type = 'BASE TABLE'
                                     AND table_name NOT LIKE 'pg_%')
              AND c.column_name = 'created_at'
            LOOP
                RAISE NOTICE 'Processing generate created_info_handler - table : [%]', t.table_name;
                EXECUTE format('DROP TRIGGER IF EXISTS tr_180_bi_created_info ON %I', t.table_name);
                EXECUTE format('CREATE TRIGGER tr_180_bi_created_info
                      BEFORE INSERT ON %I
                      FOR EACH ROW
                      EXECUTE FUNCTION created_info_handler()', t.table_name);
                RAISE NOTICE 'Created trigger for table: %', t.table_name;
            END LOOP;
    END;
$$;

-- 테이블에 갱신 Audit 트리거 생성
DO
$$
    DECLARE
        t record;
    BEGIN
        FOR t IN
            SELECT table_name
            FROM information_schema.columns c
            WHERE c.table_schema = 'public'
              AND c.table_name IN (SELECT table_name
                                   FROM information_schema.tables
                                   WHERE table_schema = 'public'
                                     AND table_type = 'BASE TABLE'
                                     AND table_name NOT LIKE 'pg_%')
              AND c.column_name = 'updated_at'
            LOOP
                RAISE NOTICE 'Processing generate updated_info_handler table: %', t.table_name;
                EXECUTE format('DROP TRIGGER IF EXISTS tr_180_bu_updated_info ON %I', t.table_name);
                EXECUTE format('CREATE TRIGGER tr_180_bu_updated_info
                       BEFORE UPDATE ON %I
                       FOR EACH ROW
                       EXECUTE FUNCTION updated_info_handler()', t.table_name);
            END LOOP;
    END;
$$;

INSERT INTO point_codes (code,
                         name,
                         description)
VALUES ('ACTIVITY_POINT', '활동 포인트', '커뮤니티 활동으로 획득 및 사용되는 포인트'),
       ('GAME_POINT', '게임 포인트', '게임에서 획득하는 포인트');

INSERT INTO public.point_policies (id,
                                   point_code,
                                   name,
                                   expiration_period_type,
                                   expiration_period,
                                   fixed_expiration_date,
                                   is_auto_issue)
VALUES (1,
        'ACTIVITY_POINT', -- point_code: 포인트 코드
        '활동 포인트', -- name: 정책 이름
        'NEVER', -- expiration_period_type: 만료 기간 타입 (무기한)
        NULL, -- expiration_period: 만료 기간 (무기한이므로 NULL)
        NULL, -- fixed_expiration_date: 고정 만료일 (사용하지 않음)
        true -- is_auto_issue: 자동 발급 여부
       ),
       (2, 'GAME_POINT', '게임 포인트', 'NEVER', NULL, NULL, true);
;

-- 기존 게시판 데이터 삭제
-- TRUNCATE boards RESTART IDENTITY CASCADE;

-- 게시판 생성
-- boards 테이블 데이터 다시 생성 (새 ID 체계 적용)
INSERT INTO public.boards (id, name, description, visibility, permission_settings, feature_settings, point_settings, display_settings, upload_settings, is_active)
VALUES
-- 메인홈
(10, '홈', '메인 홈페이지', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 1),
 jsonb_build_object('use_category', false, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 0, 'write_comment', 0, 'download_file', 0, 'like_post', 0, 'dislike_post', 0, 'like_comment', 0, 'dislike_comment', 0),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

-- 파트너
(20, '파트너', '파트너 정보 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 99, 'comment_level', 1, 'upload_level', 99),
 jsonb_build_object('use_category', false, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 0, 'write_comment', 0, 'download_file', 0, 'like_post', 0, 'dislike_post', 0, 'like_comment', 0, 'dislike_comment', 0),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

-- 스포츠 메인
(30, '스포츠소식', '스포츠 관련 정보 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

-- 스포츠 서브 카테고리
(31, '축구', '축구 관련 소식 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(32, '야구', '야구 관련 소식 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(33, '농구', '농구 관련 소식 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(34, '배구', '배구 관련 소식 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

-- VR 메인
(40, 'VR소식', 'VR 관련 소식과 정보', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

-- 열린공간 메인
(50, '열린공간', '열린 소통 공간', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', false, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

-- 열린공간 서브 카테고리
(51, '자유게시판', '자유로운 소통 공간', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', false, 'use_secret', true, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(52, '유머게시판', '유머와 재미있는 이야기', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', false, 'use_secret', true, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(53, '도전게시판', '도전과 성취를 공유하는 공간', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*', 'video/*'], 'max_files', 5),
 true),

(54, '소셜게시판', '소셜 이슈와 토론', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(55, '방송게시판', '방송 프로그램과 미디어', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(56, '분석게시판', '분석과 리서치 공유', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*', 'application/pdf'], 'max_files', 3),
 true),

-- 전용공간 메인
(60, '전용공간', '등급별 전용 공간', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', false, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

-- 전용공간 서브 카테고리
(61, '브론즈', '브론즈 등급 전용 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 2, 'comment_level', 1, 'upload_level', 2),
 jsonb_build_object('use_category', false, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(62, '실버', '실버 등급 전용 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 10, 'write_level', 10, 'comment_level', 10, 'upload_level', 10),
 jsonb_build_object('use_category', false, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

(63, '골드', '골드 등급 전용 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 20, 'write_level', 20, 'comment_level', 20, 'upload_level', 20),
 jsonb_build_object('use_category', false, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 20, 'write_comment', 2, 'download_file', 0, 'like_post', 20, 'dislike_post', -10, 'like_comment', 20, 'dislike_comment', -10),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 3),
 true),

-- 포인트샵
(70, '포인트샵', '포인트로 구매하는 상품', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 99, 'comment_level', 1, 'upload_level', 99),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 0, 'write_comment', 0, 'download_file', 0, 'like_post', 0, 'dislike_post', 0, 'like_comment', 0, 'dislike_comment', 0),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*'], 'max_files', 5),
 true),

-- 고객센터 메인
(80, '고객센터', '고객 지원 메인 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 1),
 jsonb_build_object('use_category', false, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 0, 'write_comment', 0, 'download_file', 0, 'like_post', 0, 'dislike_post', 0, 'like_comment', 0, 'dislike_comment', 0),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*', 'application/pdf'], 'max_files', 5),
 true),

-- 고객센터 서브 카테고리
(81, 'Q&A', '질문과 답변 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 1, 'comment_level', 1, 'upload_level', 1),
 jsonb_build_object('use_category', true, 'use_secret', true, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 0, 'write_comment', 0, 'download_file', 0, 'like_post', 0, 'dislike_post', 0, 'like_comment', 0, 'dislike_comment', 0),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 50),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*', 'application/pdf'], 'max_files', 5),
 true),

(82, '공지사항', '사이트 공지사항 게시판', 'public',
 jsonb_build_object('list_level', 1, 'read_level', 1, 'write_level', 99, 'comment_level', 2, 'upload_level', 99),
 jsonb_build_object('use_category', true, 'use_secret', false, 'use_comments', true, 'use_editor', true, 'use_file_upload', true, 'forbidden_words', array []::text[]),
 jsonb_build_object('read_post', 0, 'write_post', 0, 'write_comment', 0, 'download_file', 0, 'like_post', 0, 'dislike_post', 0, 'like_comment', 0, 'dislike_comment', 0),
 jsonb_build_object('posts_per_page', 20, 'new_post_hours', 24, 'hot_post_views', 100),
 jsonb_build_object('max_file_size', 5242880, 'allowed_types', array ['image/*', 'application/pdf'], 'max_files', 5),
 true);

insert into public.board_categories (board_id, name, display_order)
values (30, '전체', 1),
       (30, '인기글', 2),
       (30, '분석글', 3),
       (31, '국내', 1),
       (31, '해외', 2),
       (31, '분석', 3),
       (32, '국내', 1),
       (32, '해외', 2),
       (32, '분석', 3),
       (33, '국내', 1),
       (33, '해외', 2),
       (33, '분석', 3),
       (34, '국내', 1),
       (34, '해외', 2),
       (34, '분석', 3),
       (40, '기기', 1),
       (40, '콘텐츠', 2),
       (40, '리뷰', 3),
       (53, '스포츠', 1),
       (53, '건강', 2),
       (53, '공부', 3),
       (53, '기타', 4),
       (54, '사회', 1),
       (54, '문화', 2),
       (54, '경제', 3),
       (54, '정치', 4),
       (54, '환경', 5),
       (55, 'TV', 1),
       (55, '라디오', 2),
       (55, '스트리밍', 3),
       (55, '영화', 4),
       (55, '기타', 5),
       (56, '스포츠분석', 1),
       (56, '금융분석', 2),
       (56, '기술분석', 3),
       (56, '기타', 4),
       (70, '아이템', 1),
       (70, '이모티콘', 2),
       (70, '등급업', 3),
       (70, '기타', 4),
       (81, '일반질문', 1),
       (81, '기술질문', 2),
       (81, '기타', 3),
       (82, '일반공지', 1),
       (82, '이벤트', 2),
       (82, '업데이트', 3);

-- 기존 메뉴 데이터 삭제
-- TRUNCATE menu RESTART IDENTITY CASCADE;

-- 메뉴 생성
-- 메인 메뉴 (최상위 메뉴)
INSERT INTO menu (id, name, type, sub_type, display_order, link_url, board_id, parent_id, required_level)
VALUES (1, '메인페이지', 'link', 'common', 1, '/', 10, null, 0),
       (2, '파트너', 'link', 'common', 2, '/partners', 20, null, 0),
       (3, '스포츠소식', 'link', 'common', 3, '/board/sports?boardId=30&type=list', 30, null, 0),
       (4, 'VR소식', 'link', 'common', 4, '/board/vr?boardId=40&type=content', 40, null, 0),
       (5, '열린공간', 'link', 'common', 5, '/board/open-lounge?boardId=50&type=list', 50, null, 0),
       (6, '전용공간', 'link', 'common', 6, '/board/close-lounge?boardId=60&type=gallery', 60, null, 1),
       (7, '포인트샵', 'link', 'common', 7, '/board/point-shop?boardId=70&type=list', 70, null, 1),
       (8, '고객센터', 'link', 'common', 8, '/board/customer?boardId=80&type=list', 80, null, 0);

-- 스포츠소식 서브메뉴
INSERT INTO menu (id, name, type, sub_type, display_order, link_url, board_id, parent_id, required_level)
VALUES (9, '전체', 'board', 'common', 1, '/board/sports?boardId=30&type=gallery', 30, 3, 0),
       (10, '축구', 'board', 'common', 2, '/board/sports/football?boardId=31&type=list', 31, 3, 0),
       (11, '야구', 'board', 'common', 3, '/board/sports/baseball?boardId=32&type=list', 32, 3, 0),
       (12, '농구', 'board', 'common', 4, '/board/sports/basketball?boardId=33&type=list', 33, 3, 0),
       (13, '배구', 'board', 'common', 5, '/board/sports/volleyball?boardId=34&type=list', 34, 3, 0);


-- 열린공간 서브메뉴
INSERT INTO menu (id, name, type, sub_type, display_order, link_url, board_id, parent_id, required_level)
VALUES (14, '자유게시판', 'board', 'common', 1, '/board/open-lounge/free?boardId=51&type=list', 51, 5, 0),
       (15, '유머게시판', 'board', 'common', 2, '/board/open-lounge/humor?boardId=52&type=list', 52, 5, 0),
       (16, '도전게시판', 'board', 'common', 3, '/board/open-lounge/challenge?boardId=53&type=gallery', 53, 5, 0),
       (17, '소셜게시판', 'board', 'common', 4, '/board/open-lounge/social?boardId=54&type=gallery', 54, 5, 0),
       (18, '방송게시판', 'board', 'common', 5, '/board/open-lounge/broadcast?boardId=55&type=gallery', 55, 5, 0),
       (19, '분석게시판', 'board', 'common', 6, '/board/open-lounge/analytics?boardId=56&type=gallery', 56, 5, 0);

-- 전용공간 서브메뉴
INSERT INTO menu (id, name, type, sub_type, display_order, link_url, board_id, parent_id, required_level)
VALUES (20, '브론즈', 'board', 'common', 1, '/board/close-lounge/bronze?boardId=61&type=gallery', 61, 6, 1),
       (21, '실버', 'board', 'common', 2, '/board/close-lounge/silver?boardId=62&type=gallery', 62, 6, 10),
       (22, '골드', 'board', 'common', 3, '/board/close-lounge/gold?boardId=63&type=gallery', 63, 6, 20);

-- 고객센터 서브메뉴
INSERT INTO menu (id, name, type, sub_type, display_order, link_url, board_id, parent_id, required_level)
VALUES (23, 'Q&A', 'board', 'common', 1, '/board/customer/qna?boardId=81&type=list', 81, 8, 0),
       (24, '공지사항', 'board', 'common', 2, '/board/customer/notice?boardId=82&type=list', 82, 8, 0);

-- 파트너 사이트 메뉴 (별도 타입으로 구분)
INSERT INTO menu (id, name, type, sub_type, display_order, link_url, board_id, parent_id, required_level)
VALUES (25, '제휴사이트 1', 'link', 'partner', 1, '/partner/1', null, null, 0),
       (26, '제휴사이트 2', 'link', 'partner', 2, '/partner/2', null, null, 0),
       (27, '제휴사이트 3', 'link', 'partner', 3, '/partner/3', null, null, 0),
       (28, '제휴사이트 4', 'link', 'partner', 4, '/partner/4', null, null, 0);
;

INSERT INTO public.user_level_configs (level, required_points)
VALUES
    -- 1-10 레벨: 500씩 증가
    (1, 100),
    (2, 1000),    -- +1,000
    (3, 1500),    -- +500
    (4, 2000),    -- +500
    (5, 2500),    -- +500
    (6, 3000),    -- +500
    (7, 3500),    -- +500
    (8, 4000),    -- +500
    (9, 4500),    -- +500
    (10, 5000),   -- +500 (10레벨 구간)

    -- 11-20 레벨: 1,000씩 증가
    (11, 6000),   -- +1,000
    (12, 7000),   -- +1,000
    (13, 8000),   -- +1,000
    (14, 9000),   -- +1,000
    (15, 10000),  -- +1,000
    (16, 11000),  -- +1,000
    (17, 12000),  -- +1,000
    (18, 13000),  -- +1,000
    (19, 14000),  -- +1,000
    (20, 15000),  -- +1,000 (20레벨 구간)

    -- 21-30 레벨: 2,000씩 증가
    (21, 17000),  -- +2,000
    (22, 19000),  -- +2,000
    (23, 21000),  -- +2,000
    (24, 23000),  -- +2,000
    (25, 25000),  -- +2,000
    (26, 27000),  -- +2,000
    (27, 29000),  -- +2,000
    (28, 31000),  -- +2,000
    (29, 33000),  -- +2,000
    (30, 35000),  -- +2,000 (30레벨 구간)

    -- 31-40 레벨: 4,000씩 증가
    (31, 39000),  -- +4,000
    (32, 43000),  -- +4,000
    (33, 47000),  -- +4,000
    (34, 51000),  -- +4,000
    (35, 55000),  -- +4,000
    (36, 59000),  -- +4,000
    (37, 63000),  -- +4,000
    (38, 67000),  -- +4,000
    (39, 71000),  -- +4,000
    (40, 75000),  -- +4,000 (40레벨 구간)

    -- 41-50 레벨: 8,000씩 증가
    (41, 83000),  -- +8,000
    (42, 91000),  -- +8,000
    (43, 99000),  -- +8,000
    (44, 107000), -- +8,000
    (45, 115000), -- +8,000
    (46, 123000), -- +8,000
    (47, 131000), -- +8,000
    (48, 139000), -- +8,000
    (49, 147000), -- +8,000
    (50, 155000); -- +8,000 (최종 레벨)

INSERT INTO public.report_types (code, name, description, display_order)
VALUES ('SPAM', '스팸 홍보/도배', '영리 목적의 광고, 홍보성 게시물, 반복적인 도배 글', 1),
       ('ABUSE', '욕설/비하', '욕설, 비방, 모욕적인 표현, 혐오 발언 등', 2),
       ('ADULT', '음란물/불법정보', '성적인 컨텐츠, 불법적인 정보, 청소년 유해 컨텐츠', 3),
       ('IMPERSONATION', '사칭/명의도용', '다른 사용자나 유명인을 사칭하는 행위', 4),
       ('COPYRIGHT', '저작권 침해', '저작권법을 위반한 컨텐츠, 무단 도용', 5),
       ('PERSONAL_INFO', '개인정보 노출', '개인정보 무단 게시, 초상권 침해', 6),
       ('FRAUD', '사기/허위정보', '허위 사실 유포, 사기성 정보, 가짜 뉴스', 7),
       ('OTHER', '기타', '위 유형에 해당하지 않는 기타 신고 사유', 99)
ON CONFLICT (code) DO UPDATE SET name          = EXCLUDED.name,
                                 description   = EXCLUDED.description,
                                 display_order = EXCLUDED.display_order,
                                 updated_at    = now();

-- 배너 샘플 데이터 삽입
INSERT INTO public.banners
    (title, description, position, image_url, link_url, target_window, start_at, end_at, display_order, target_devices, width, height, is_responsive, status, created_by)
VALUES
-- 메인 상단 배너
('신규 회원 가입 이벤트', '신규 회원 가입 시 1,000 포인트 지급!', 'TOP', '/public/img/upload_test.jpg', '/signup', '_self', '2025-01-01 00:00:00', '2025-12-31 23:59:59', 10, ARRAY ['PC'::public.device_type, 'MOBILE'::device_type, 'TABLET'::public.device_type], 800, 120, true, 'ACTIVE', 1),
-- 메인 중앙 배너
('5월 이벤트', '가정의 달 맞이 특별 이벤트', 'CENTER', '/public/img/upload_test.jpg', '/events/may', '_blank', '2025-05-01 00:00:00', '2025-05-31 23:59:59', 20, ARRAY ['PC'::public.device_type, 'MOBILE'::public.device_type, 'TABLET'::public.device_type], 1200, 400, true, 'ACTIVE', 1),
-- 우측 사이드 배너
('VIP 등급 혜택 안내', 'VIP 회원만의 특별한 혜택을 확인하세요', 'RIGHT_SIDE', '/public/img/upload_test.jpg', '/membership/vip', '_self', '2025-01-01 00:00:00', '2025-12-31 23:59:59', 30, ARRAY ['PC'::public.device_type], 300, 500, false, 'ACTIVE', 1),
-- 플로팅 배너
('긴급 공지', '서버 점검 안내: 5월 10일 새벽 2시~4시', 'FLOATING', '/public/img/upload_test.jpg', '/notice/server-maintenance', '_self', '2025-05-08 00:00:00', '2025-05-10 04:00:00', 5, ARRAY ['PC'::public.device_type, 'MOBILE'::public.device_type, 'TABLET'::public.device_type], 400, 200, true, 'DRAFT', 1),
-- 팝업 배너
('개인정보처리방침 개정 안내', '2025년 6월 1일부터 개인정보처리방침이 개정됩니다', 'POPUP', '/public/img/upload_test.jpg', '/privacy-policy', '_blank', '2025-05-15 00:00:00', '2025-06-01 00:00:00', 1, ARRAY ['PC'::public.device_type, 'MOBILE'::public.device_type, 'TABLET'::public.device_type], 600, 400, false, 'PAUSED', 1);

-- site_config_kv 테이블 샘플 데이터 삽입
insert into public.site_config_kv (key, value, description, updated_at, updated_by)
values  ('user.register_level', '1', '회원 가입 시 기본 등급', '2025-08-17 08:28:03.547369 +00:00', null),
        ('user.register_point', '500', '회원 가입 시 지급 포인트', '2025-08-17 08:28:03.547369 +00:00', null),
        ('user.login_point', '10', '로그인 시 지급 포인트', '2025-08-17 08:28:03.547369 +00:00', null),
        ('user.nickname_change_interval_days', '30', '닉네임 변경 가능 간격 (일)', '2025-08-17 08:28:03.547369 +00:00', null),
        ('upload.allowed_ext.image', '["jpg", "jpeg", "gif", "png", "webp"]', '이미지 파일 허용 확장자', '2025-08-17 08:28:03.547369 +00:00', null),
        ('upload.allowed_ext.video', '["mp4", "webm"]', '비디오 파일 허용 확장자', '2025-08-17 08:28:03.547369 +00:00', null),
        ('upload.allowed_ext.document', '["pdf", "doc", "docx"]', '문서 파일 허용 확장자', '2025-08-17 08:28:03.547369 +00:00', null),
        ('upload.max_size.user_avatar', '{"size": 2048000, "width": 200, "height": 200}', '사용자 아바타 최대 크기 설정', '2025-08-17 08:28:03.547369 +00:00', null),
        ('upload.max_size.user_image', '{"size": 5242880, "width": 1200, "height": 1200}', '사용자 이미지 최대 크기 설정', '2025-08-17 08:28:03.547369 +00:00', null),
        ('terms.version', '"1755009139.433475"', '이용약관 버전', '2025-08-17 08:28:03.547369 +00:00', null),
        ('maintenance_mode', 'false', '사이트 점검 모드 활성화 여부', '2025-08-17 08:28:03.547369 +00:00', null),
        ('site.name', '"Site Config"', '사이트 이름', '2025-08-17 08:28:03.547369 +00:00', null),
        ('site.title', '"커뮤니티 타이틀"', '사이트 타이틀', '2025-08-17 08:28:03.547369 +00:00', null),
        ('site.contact_email', '"admin@example.com"', '사이트 연락처 이메일', '2025-08-17 08:28:03.547369 +00:00', null),
        ('user.profile_fields', '{"mobile": {"use": true, "required": false}, "address": {"use": false, "required": false}, "profile": {"use": true, "required": false}, "signature": {"use": true, "required": false}}', '사용자 프로필 필드 설정', '2025-08-17 08:28:03.547369 +00:00', null),
        ('site.forbidden_words', '["fuck"]', '금지어 목록', '2025-08-17 08:28:03.547369 +00:00', null),
        ('site.terms_of_service', '"서비스 약관 텍스트"', '서비스 이용약관', '2025-08-17 08:28:03.547369 +00:00', null),
        ('site.privacy_policy', '"개인정보 약관 텍스트"', '개인정보 처리방침', '2025-08-17 08:28:03.547369 +00:00', null),
        ('cleanup.days_visit_logs', '90', '방문 로그 정리 주기 (일)', '2025-08-17 08:28:03.547369 +00:00', null),
        ('cleanup.days_member_leave', '30', '탈퇴 회원 정보 정리 주기 (일)', '2025-08-17 08:28:03.547369 +00:00', null),
        ('site.enable_ip_base_view_count', 'false', 'IP 기반 조회수 중복 방지 활성화', '2025-08-17 08:28:03.547369 +00:00', null);

INSERT INTO public.coin_types (coin_code, coin_name, coin_symbol, display_order, description)
VALUES ('bitcoin', '비트코인', 'BTC', 1, null),
       ('ethereum', '이더리움', 'ETH', 2, null),
       ('ripple', '리플', 'XRP', 3, null),
       ('other', '기타', 'OTHER', 99, '목록에 없는 기타 코인')
ON CONFLICT (coin_code) DO NOTHING;

INSERT INTO public.challenge_action_types (action_code, name, description)
VALUES ('comment', '댓글 작성', '댓글을 작성하는 액션'),
       ('post', '게시물 작성', '게시물을 작성하는 액션'),
       ('reaction', '추천', '게시물이나 댓글을 추천하는 액션'),
       ('download', '다운로드', '파일을 다운로드하는 액션'),
       ('composite', '복합', '여러 챌린지를 조합한 액션')
ON CONFLICT (action_code) DO NOTHING;

INSERT INTO public.challenge_types (type_code, name, description)
VALUES ('daily', '일일 챌린지', '매일 초기화되는 챌린지'),
       ('accum', '누적 챌린지', '누적으로 진행되는 챌린지')
ON CONFLICT (type_code) DO NOTHING;

INSERT INTO public.challenge_codes (code, description, category)
VALUES ('D_POST_10', '일일 글쓰기 10회', 'daily'),
       ('D_REACTION_10', '일일 추천 10회', 'daily'),
       ('D_COMMENT_10', '일일 댓글 10회', 'daily'),
       ('D_DOWNLOAD_3', '일일 다운로드 3회', 'daily'),
       ('D_ALL_CLEAR', '모든 일일 챌린지 완료', 'daily')
ON CONFLICT (code) DO NOTHING;

INSERT INTO public.challenges (code, name, type_code, action_code, target_count, reward_point, sort_order)
VALUES ('D_POST_10', '글쓰기', 'daily', 'post', 10, 100, 1),
       ('D_REACTION_10', '추천', 'daily', 'reaction', 10, 20, 2),
       ('D_COMMENT_10', '댓글', 'daily', 'comment', 10, 30, 3),
       ('D_DOWNLOAD_3', '다운로드', 'daily', 'download', 3, 50, 4),
       ('D_ALL_CLEAR', '모든 일일 챌린지 성공', 'daily', 'composite', 1, 500, 5)
ON CONFLICT (code) DO NOTHING;

-- D_ALL_CLEAR 복합 챌린지 의존성 설정
UPDATE public.challenges
SET depends_on = ARRAY ['D_POST_10', 'D_REACTION_10', 'D_COMMENT_10', 'D_DOWNLOAD_3']
WHERE code = 'D_ALL_CLEAR'
  AND depends_on IS NULL;

INSERT INTO public.migrations (version, description)
VALUES ('36', 'MIG'),
       ('37', 'MIG'),
       ('38', 'MIG'),
       ('39', 'MIG'),
       ('40', 'MIG'),
       ('41', 'MIG'),
       ('42', 'MIG'),
       ('43', 'MIG'),
       ('44', 'MIG'),
       ('45', 'MIG'),
       ('46', 'MIG'),
       ('47', 'MIG')
;

